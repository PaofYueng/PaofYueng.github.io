---
title: '数据库原理-笔记'
date: 2021-01-05 20:01:10
tags:
- 课程笔记
mathjax: true
---

# 数据库原理-笔记

## 前言

> 12周结课，20周考，真有你的，吉林大学

<!-- more -->		

## 引言

数据库系统需要解决的问题：

1. 数据的冗余与不一致，冗余即重复存储，不一致指同一数据的不同副本不一致
2. 数据孤立，需要将数据整合起来方便查找
3. 完整性问题，需要保证数据的值满足一定的约束
4. 原子性问题，对数据库的操作需要是原子的
5. 并发访问异常，确保并发操作的正确性
6. 安全性问题，权限管理

数据视图

1. 物理层：数据的物理存储，例B树
2. 逻辑层：数据的逻辑存储，例表
3. 视图层：只描述了数据的某个部分，例视图

实例：某一时刻信息的集合
模式：数据库的整体设计

数据模型

1. 数据模型，描述数据，数据联系，数据语义与一致性约束的公式
2. 关系模型，实体联系模型，基于对象的数据模型，半结构化数据模型

DML 数据操纵语言——增删改查

DDL 数据定义语言——定义了数据库模式的实现细节

1. 域约束，属性的定义域
2. 参照完整性，外键
3. 断言，持久的内容约束
4. 授权

DDL的数据存放于数据字典（数据库信息的表），其包含元数据（数据库的数据）

设计过程：需求分析-概念设计-实现

## 关系模型介绍

关系数据库是表的集合，关系指代表，元组指代行，属性指代列

数据库模式是数据库的逻辑设计
数据库实例是给定时刻数据库的数据的快照

### 码

1. 超码是一个或一组能唯一标识一个元组的属性
2. 候选码是最小超码
3. 主码是设计者选中的超码
4. 外码，参照关系的实现，一般是约束该属性的取值来自于另一关系的主码

## SQL

主要有DDL,DML,完整性，视图定义，事务控制与授权组成

数据库的基本类型

1. char，定长字符串
2. varchar，变长字符串
3. int，整型
4. smallint，小整型
5. numeric，定点数
6. real，double precision，浮点数，双精度浮点数
7. float(n)，精度至少为n的浮点数

### CREATE

```sql
CREATE TABLE R(
	A1 D1,
	//...
	AN DN.
	primary key (id),
	foreign key (name) reference r2
);
```

### INSERT

```sql
insert into r values(a1,a2,...,an)
```

### DELETE 

```sql
delete from student
```

删除元组

### drop

```sql
drop table r
```

删除表

### alter

```sql
alter table r add A D;
alter table r drop B
```

表属性操作

### select

```sql
select * from r ;
select * from r1,r2 where r1.A=r2.A;
select * from r1 natural join r2 where P;
select * from r as r1,r as r2 where r1.A=r2.A;
select * from r where A like '%___%' ;
(select * from r where P1) union (select * from r where P2);
(select * from r where P1) intersect (select * from r where P2);#交
(select * from r where P1) except (select * from r where P2);#差
```

选择所有=不存在没被选择

```sql
select name 
from student 
where student not exists 
  ((select course_id 
  from cource 
  where dept_name=’Comp. Sci.’)except(
    select course_id from takes where ID=student.ID))
```



### null

对于and与or短路与断路依旧存在，对于比较运算与非运算结果均为unknown，判断是不是null 用 is null 语句，判断是否为unknown 用is unknown语句

### 聚集函数

avg,min,max,sum,count

分组聚集group by，按照属性值分组后每组分别进行聚集函数

having 对于分组的筛选

### in

嵌套子查询中，判断元组是否在子查询结果中

```sql
select * from r
where A1 in(
	select A1
	from r
	where P
)
```

### some,all

与in类似，some存在成立则成立，all存在不成立则不成立

### 相关子查询

select内的子查询必须要是标量子查询（只返回一个数）

父查询的表可用于子查询中

```sql
select *
from r as r1
where 1>(
	select *
	from r as r2
	where r1.A=r2.A
)
```

### 增删改查

```sql
delete from r where P;
insert into course (A2,A4) values (a2,a4);
insert into r1
	select * from r2;
update r1 set A1=f(A1) where P;
```

## 中级SQL

内连接：不保留匹配失败的元组

全/左/右外连接：保留全/左/右表未匹配信息

### 视图

对用户可见的虚关系

```sql
create view v as
select A1,A2..,AN
from r
where P
```

可更新条件：来自单表，只包含属性，不出现在select中的属性均可为空，无分组

### 事务

事务由查询或更新语句的序列组成。

commit work:提交事务，标志事务完成
rollback work:回滚事务

原子的，全执行或全不执行，二择一

### 完整性约束

1. not null
2. unique
3. default
4. primary key
5. foreign key
6. check

### 权限

```sql
grant [select | insert | update | delete]
on r
to user/role;
revoke [select | insert | update | delete]
on r
from user/role;
```

角色

```sql
create role a
```

是权限与角色的集合

权限的回收具有级联问题

### 触发器

可以用于完整性约束的实现，可指定在指定操作的前后执行

## 关系代数

$$
选择\ \sigma_P(r)\\
投影\ \Pi_A(r)\\
并\ r1\cup r2\\
差\ r1-r2\\
笛卡尔积\ r1\times r2\\
改名 \rho_x(r)\\
自然连接\ r1\Join r2=\Pi_{R1\cup R2}(\sigma_{r1.A1=r2.A1\and r1.A2=r2.A2\and ...\and r1.An=r2.An}(r1\times r2))\\
赋值运算\ E1\leftarrow E2\\
外连接\ r⟕s=r\Join s\cup(r-\Pi_R(r\Join s))\times\{(null,null,...,null)\}\\
聚集函数\ _{A1}\mathcal{G}_{f(A2)}(r)
$$

### 元组关系演算

标准表达用文字书写为“他是满足如下条件的元组t的集合，在关系r中存在元组s是t和s在主键相等，且s在属性A上满足表达式P”
$$
\{t|\exist s \in r(t[PK]=s[PK]\and P(s[A])\}
$$

## ER模型

好的模型设计需要避免冗余与不完整

实体，可以是实在的或抽象的事物与对象
实体集，相同类型的实体的集合
联系，实体间的相互关联,如(e1,e2)
联系集，相同类型联系的集合,联系集可以具有描述性属性

联系集是自环的:$R=\{(e_1,e_2)|e_1\in E ,e_2\in E\}$
度，参与联系集的实体集数目

简单属性-复合属性：是否可再分
单值属性-多值属性：某一实体的某一属性是否唯一
派生属性：可由已有属性推导出

映射基数：一对一，一对多，多对一，多对多

参与约束：实体集中所有实体都参与了联系集，则称为全部的，否则称为部分的

多对一的联系集中，多的实体集的主码可以作为联系集的主码

## 关系数据库的设计

有损分解，分解后再连接存在数据错误

第一范式：要求属性都为简单属性

函数依赖存在属性A,B由唯一决定的$B=f(A)则A\rightarrow B$

若存在$\alpha,\beta有\alpha\rightarrow\beta且\beta\in\alpha$则称该函数依赖为平凡的，即我确定我自己

BCNF：
对于模式的函数闭包中的任意函数依赖$\alpha\rightarrow\beta$
若都为平凡的或$\alpha$为超码，则该模式为BCNF

分解，将函数依赖移除并存入新的模式中即可

BCNF分解可能会破坏函数依赖，我们希望保持依赖，故有第三范式
比BCNF多出一个成立条件$\beta-\alpha$中的每个属性A都包含与R的一个候选码中

### 函数依赖理论

正则覆盖

①合并$\alpha_1\rightarrow\beta_1,\alpha_1\rightarrow\beta_2$
②寻找任意函数依赖，与其有无关属性
③删除无关属性

3NF分解

①求正则覆盖
②每个函数依赖的左部和右部组合为新模式
③保证存在模式集中存模式包含原模式的候选码

## 事务

ACID：

1. 一致性：与预期保持一致
2. 原子性：都做或都不做
3. 持久性：保证事务结束后数据写在了磁盘上
4. 隔离性：不同事务若会相互影响需要隔离

### 可串行化

关注read和write操作

冲突等价，调度可经过非冲突指令相互交换

优先图中存在$T_i\rightarrow T_j$

1. 在$T_j$执行read(Q)前，$T_i$执行write(Q)
2. 在$T_j$执行write(Q)前，$T_i$执行read(Q)
3. 在$T_j$执行write(Q)前，$T_i$执行write(Q)

