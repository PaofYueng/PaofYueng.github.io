---
title: 操作系统-笔记
date: 2020-07-19 18:12:45
tags:
- 课程笔记
mathjax: true
---

# 操作系统笔记

## 前言

​		交叉范围极广的学科，与其他科目最大的区别在于资源配置方面的知识。

<!-- more -->		

## 第一章-操作系统概述

### 基础知识

操作系统地位：硬件上软件下

操作系统作用：

​	① 配置资源
​	② 提供界面

操作系统历史：

手工操作阶段-批处理阶段-执行系统阶段

操作系统特性：

​	① 并发性：宏观上同时运行多个程序
​	② 共享性：在操作系统配置下多个程序共用软硬件资源
​	③ 异步性：多个程序已不可预知的速度向前推进
​	④ 虚拟性：通过虚拟技术虚拟出多中虚拟硬件资源

操作系统运行环境：

​	① 定时装置：即时钟，有记录时间的**绝对时钟**也有控制终端的**间隔时钟**
​	② 系统栈：保护终端现场（**函数调用返回点、参数、局部变量、返回值**）
​	③ 特权指令与非特权指令：仅管态才能运行的为特权指令。
​	④ 处理机状态：管态与目态
​	⑤ 地址映射：将逻辑地址转化为物理地址，以提供虚拟内存。
​	⑥ 存储保护设施：防止越界越权，保护隐私。
​	⑦ 中断装置：当前（PSW，PC）到系统栈。中断向量（PSW，PC）到寄存器
​	⑧ 通道与DMA：处理IO的处理机，DMA没有独立的指令系统。
​	⑨ IO保护：所有的IO指令都为特权指令。

我们应当从进程，资源管理，虚拟机三个视角充分考量操作系统。

### 系统类型

手工操作阶段： 通过穿孔纸带输入数据，输出由打字机输出。

批处理阶段：

​	① 联机批处理：在没有人工干预的情况下由读卡器批量读入数据。
​	② 脱机批处理：由卫星机处理数据并用人力将处理后的数据输入计算机。

执行系统阶段：由通道进行输入输出。

多道批处理系统：由输入输出井缓存数据实现作业调度。

分时操作系统：资源分时得分配给多个终端。多路，交互，独占

实时操作系统：实时响应。实时，可靠

通用操作系统：同时具有分时、实时、批处理功能。

其他操作系统还有：单用户操作系统，网络操作系统，分布式操作系统，多处理机操作系统，嵌入式操作系统，多媒体操作系统，智能卡操作系统。



## 第二章-进程、线程与作业

为了提高吞吐量与资源使用率，我们从单道程序转向了多道程序。



### 进程

定义：可参与**并发**执行的程序称为进程。进程是具有一定独立功能的程序关于一个数据集合的一次**运行**活动。

并发：宏观上的同时，交替进行即可——并行：微观同时，要求多个CPU

进程状态有运行态、就绪态与等待态，关键在于通过IO获得资源与得到处理机。

PCB内容：进程标识(pid)、家族联系、进程状态 、地址信息、现场信息、打开文件、调度参数、消息指针、所属用户(uid) 、队列指针

程序：代码、数据、堆栈

进程上下文指进程本身与其运行的环境当进程切换时上下文也随之切换，这个过程需要系统支出时间与空间，这部分开销我们称之为系统开销。

进程队列
就绪队列：系统一个或若干个（根据调度算法确定）
等待队列：每个等待事件一个
运行指示字：每个处理机一个

进程分为系统进程与用户进程。

进程的特征
并发性：可以与其它进程一道向前推进；
动态性：动态产生、消亡，生存期内状态动态变化；
独立性：一个进程是可以调度的基本单位；
交往性：同时运行的进程可能发生相互作用；
异步性：进程以各自独立，不可预知的速度向前推进；
结构性：每个进程有一个PCB。

进程的创建：建立PCB，分配内存，加载程序，入就绪链。
进程的撤销：去配资源，撤销PCB，通知父进程。

**进程与程序的联系与差别**

进程与程序的联系
进程包括一个程序，进程存在的目的就是执行这个程序

进程与程序的差别
程序静态，进程动态；程序可长期保存，进程有生存期；一个程序可对应多个进程，一个进程只能执行一个程序。

### 线程

将上下文削减至寄存器和用户栈，令线程成为进程执行的单位，同时可用于提升执行单位的耦合关系差的缺陷

TCB
内容：线程标识、线程状态、调度参数、现场(通用寄存器，PC,SP)、链接指针。

### 作业

作业与进程：作业进入内存后变为进程，一个作业通常与多个进程相对。

将进程分为两部分，仅在内存才需要的信息放在User结构，无论在哪都需要的信息存在Proc结构。

pid=fork()
execl(prog,arg0,agrn-1,0)
exit()
pid=wait

## 第三章-中断与处理机调度

### 中断

硬件负责识别中断源并排队，保存现场，引出中断处理程序。

中断源：引起中断的事件。
中断寄存器：保存与中断事件相关信息的寄存器。
中断字：中断寄存器的内容。
中断向量：中断处理程序的运行环境与入口地址（PSW，PC）

强迫性中断

运行程序不期望的
	时钟中断
	IO中断
	控制台中断
	硬件故障中断：power failure、内存校验错
	程序性中断：越界，越权、缺页、溢出，除0、非法指令

自愿性中断
	运行程序期望的：系统调用、访管指令
	系统调用：fd=open(fname,mode)
	访管指令：准备参数、svc n、取返回值

在受到中断信号时系统都会关中断，而在进入中断处理前会开放高优先级中断，处理完中断后也会关中断。

一定进程切换的类型有：进程中断，进程结束，进程等待输入输出。

### 处理机调度

处理机调度要尽量提升CPU利用率和吞吐量，同时减少周转时间响应时间和系统开销。

调度方法分为剥夺式和非剥夺式调度，区别在于是否抢占运行进程的CPU。

#### 调度参数

周转时间：完成时间-进入时间
平均周转时间：周转时间的平均值
带权周转时间：周转时间/运行时间
平均带权周转时间：带权周转时间的平均值

#### 先到先服务算法

如名所示，是一种公平的算法但可能导致短作业等待时间过长

#### 短作业优先算法

如名所示，可能导致长作业饿死

#### 最短剩余时间优先算法

若有新任务剩余时间短于当前进程则中断当前进程处理最短剩余时间进程。

#### 最高响应比优先算法

$响应比=(bursttime+waittime)/bursttime$

#### 最高优先数算法

优先数可变与否可分为静态优先数与动态优先数。

#### 循环轮转算法

适用于分时系统。当时间片过长响应速度很慢，而过短则会增加系统开销

#### 多级排列算法

在通用系统中将任务分类排列。

#### 反馈排队算法

优先级越高时间片越小，新作业到达时即在队首。

#### 处理机调度过程

保存下降进程的现场
寄存器(PSW,PC,SP,通用寄存器,地址寄存器)->PCB
选择上升进程
按处理机调度算法
恢复上升进程的现场
PCB ->寄存器
先恢复通用寄存器和地址寄存器,最后恢复PSW,PC
PSW和PC必须用一条指令恢复

#### 实时调度

硬实时(hard real-time): 必须满足任务截止期要求 . 
软实时(soft real-time): 期望满足截止期要求 . 
周期性: 每隔固定时间发生一次 
随机性: 由随机事件触发，其发生时刻不确定 

Ready time: 就绪时间
Starting deadline: 开始截止期
Processing time: 处理时间
Completion deadline: 完成截止期
Occurring period:发生周期
Occurring frequency: 发生频率

周期性实时事务可调度的要求是，每个任务处理时间发生周期比的和小于等于1

#### 最早截止期调度

优先调度截止期最早的实时任务，是种剥夺式的调度算法，可调度的充分条件如上。

#### 速率单调调度

优先处理发生周期最短的实时任务，时钟非剥夺式的算法。可调度的充分条件为$\Sigma_{i=1}^n\frac{C_i}{T_i}\leq n(2^\frac{1}{n}-1)$。

## 第四章-互斥同步与通讯

共享变量（shared variable）：多个进程都需要访问的变量。
临界区域（critical region）：访问共享变量的程序段。把临界区与其所对应的共享变量联系起来称为关于某一种共享变量的临界区

互斥需要满足的性质：
互斥性(mutual exclusion)，进展性(progress)，有限等待性(bounded waiting)

### 单处理机互斥算法

```c++
//Dekker
void Lock(int id){
	int wait_count=0;
	flag[id] = 1;
	while (flag[!id]) {
		if (turn == !id) {
			flag[id] = 0;
			while (turn == !id) {
				wait_count++;
			}
			flag[id] = 1;
		}
	}
	printf("the count of wait:%d ", wait_count);
    wait_count=0;
}
void unLock(int id){
    turn=!id;
    flag[id]=0;
}

//Peterson
void Lock(int id){
	int wait_count=0;
	flag[id] = 1; turn = !id;
	while (flag[!id] && turn == !id) 
		wait_count++;
	printf("the count of wait:%d ", wait_count);
    wait_count=0;
}
void unLock(int id){
    flag[id]=0;
}

//Lamport
void Lock(int id){
	choosing[id] = true;
	for (int i = 0; i < 5; i++) {
		number[id] = max(number[i], number[id]);
	}
	number[id]++;
	choosing[id] = false;
	for (int i = 0; i < 5; i++) {
		while (choosing[i]);
		while (number[i] != 0 && (number[i] < number[id] || (number[i] == number[id] && i < id)));
	}
}
void unLock(int id){
	number[id] = 0;
}

//Eisenberg_Mcguire
void Lock(int id){
	flag[id] = 1;
	int j = turn;
	while (j != id) {
		if (flag[j] != 0)j = turn;
		else j = (j + 1) % 5;
	}
	flag[id] = 2;
	j = 0;
	while (j < 5 && (j == id || flag[j] != 2))j++;
	turn = id;
}
void unLock(int id){	
    int j = (turn + 1) % 5;
	while (flag[j] == 0) j = (j + 1) % 5;
	turn = j;
	flag[id] = 0;
}
```

### 同步与PV操作

不同进程间存在相互等待与相互唤醒的制约关系，我们称之为进程同步。我们往往利用PV操作实现，其次PV操作也可以用于互斥。



```c++
//P原语
void getSemaphore(Semaphore *sem, TCB *tcb)
{
	/*在此处实现获取信号量的处理逻辑*/
	while(!getLock(&sem->lock)); // 获取互斥锁
	sem->value--;        // value 减一
	if (sem->value < 0) {
		InsertTailList(sem->queue, &tcb->List);//将当前线程插入到queue中
		releaseLock(&sem->lock);//释放互斥锁
		while (getLock(&g_ScheduleLock)); // 获取调度锁
		tcb->State = BLOCKED;//将当前线程状态改为阻塞
		((TCB*)tcb)->Lock[((TCB*)tcb)->postLockCount] = &g_ScheduleLock;
		((TCB*)tcb)->postLockCount++;//推迟调度锁的释放
		schedule();//调度
	}
	else {
		releaseLock(&sem->lock);//释放互斥锁
	}
}

//V原语
void releaseSemaphore(Semaphore* sem)
{
	/*在此处实现释放信号量的处理逻辑*/
	while (!getLock(&sem->lock));	//获取互斥锁
	sem->value++;	//value减一
	if (sem->value <= 0) {
		while (!getLock(&g_ScheduleLock));		//获取调度锁
		TCB * tcb= (PTCB)RemoveHeadList(sem->queue);		//取queue首部的TCB，修改其状态位就绪，并加入到就绪队列
		tcb->State = READY;
		InsertTailList(CurrentArrayList[tcb->Priority], &tcb->List);
		releaseLock(&g_ScheduleLock);		//释放调度锁
	}
	releaseLock(&sem->lock);	//释放互斥锁	
}

```

当信号量初始值为0时，进行P操作的进程必须等待另一进程对应的V操作才能继续运行，故而可以进行进程同步。

而当信号量初始值大于0时，初始值即为同种资源量，可以进行互斥操作。

生产者/消费者问题进程同步即可解决。

而对于读者/写者问题，对于读者而言，只要没有写者在操作即可操作，而当写者操作时，有且只有他一人可以进行操作。
我们需要两个信号量，一个信号量用于用于读者队列人数这个变量的互斥，另一个信号量保证读写互斥，与读读不互斥。

### 管程

相当于对共享变量统一管理，让其只能通过管程预设的子程序操作共享变量

入口等待队列->条件等待队列->紧急等待队列

当P唤醒Q时
P紧急等待，Q继续，直到Q退出或等待；(Hoare)
	Signal and urgent wait
Q等待，P继续，直到P退出或等待；(Java)
	Signal and continue
	被唤醒进程需要重新检查等待条件,可能再次等待.
唤醒是管程中可执行的最后一个操作。(Hansen)
	Signal and leave

## 第五章-死锁和饥饿

一组进程中的每一个进程，均无限期地等待此组进程中某个其他进程占有的，因而永远无法得到的资源，这种现象称为进程死锁。

### 死锁

死锁类型：
竞争资源，进程通讯，其他类型
死锁条件：（只有在每类资源只有一个实例是充要条件，否则是必要条件）
资源独占，不可抢占，保持申请，循环等待

资源分配图的约简：
① 寻找一个非孤立且没有请求边的节点pi, 若无算法结束
② 去除pi的所有分配边使其成为一个孤立节点;
③ 寻找所有请求边都可满足的进程pj, 将pj的所有请求边全部改为分配边;
④ 转步骤1

若算法结束时,所有节点均为孤点,则称资源分配图是完全可约简的,否则称为不可完全约简的.
死锁定理:
S为死锁状态的充分必要条件是S的资源分配图不可完全约简.

死锁预防：
	预先分配法：若能满足需求则分配，否则什么都不给。
	有序分配法：占有序数高的资源的进程可以申请到序数低的资源。

死锁避免：
	银行家算法：

​		资源分配：
​		① $request[i]\leq need[i]$
​			若否，请求超量，错返。
​		② $request[i]\leq available$
​			若否，不满足，等待。
​		③ 预分配，若安全则进程继续，若否，去配，进程等待。

​		安全性检测：
​		若分配后能满足所有进程都可完成，则安全。

死锁检测：
	若该时刻所有请求都可按一定处理顺序保证最终所有进程可完成则证明无死锁。
	我们一般在等待时检测，定时检测以及在资源利用率下降时检测。

死锁恢复：重新启动（代价大），终止进程，剥夺资源+进程回退。

### 饥饿与活锁

当等待时间给进程推进和响应带来明显影响时,称发生了进程饥饿.饥饿到一定程度的进程所赋予的使命即使完成也不再具有实际意义时称该进程被饿死。

等待分忙式等待与排队等待（等待被唤醒），忙式等待（反复询问资源）下的饥饿称为活锁。

## 第六章-存储管理

存储管理功能：
	存储的分配和去配，存储共享，存储保护，存储扩充（虚拟存储），地址映射。

碎片处理：移动占用区域，是所有空闲区域连成一片。

### 页式存储

静态分区（在系统初始化确定分区方式）
等长分区（每页大小相同），长$2^i$
内存分配方式：
	字位映像图：建立数组为每一页的状态提供标记。
	空闲页面表：对于连续的空闲页面，只需记录首页号和空页数。
	空闲页面链：为空闲的页面建立链表。
$逻辑地址=逻辑页号\times 2^i+页内地址$
地址映射：
	① 先查物理页号，先查快表，再查页表得到f，若从页表获得需淘汰快表中一个元素。
	② 由物理页号与页内偏移合并得物理地址。

有效访问时间 EAT=快表命中率\*(块表访问时间+内存访问时间)+快表不中率

### 段式存储

动态分区（申请时确定分区大小）
异长分区（分区大小按实际情况决定）
内存分配方式：
	所需数据结构：一个记录空闲区首址与空闲区长度的数组。
	最先适应算法：找到第一个满足条件的区域。
	下次适应算法：找到上一次分配后的第一个满足的区域。
	最佳适应算法：找到最小可满足区域。
	最坏适应算法：找打最大可满足区域。
地址映射：物理地址=段首址+段内地址
需要一个段表存储段号相应的段首值与段长度

### 界地址管理方式

动态异长。只需要记录首址与空间大小。
逻辑空间从0开始，与内存空间差一个首址。

### 段页式存储

内存空间划分静态等长，进程空间划分动态异长。即将内存按页划分，给每个进程不同的页数。
每个进程需要一个段表，每个段需要一个页表，总页表则全系统一个。
对于某进程，我们需要找到他的段表基址，与段表限长，以找到其逻辑页首址与页长，再从段对应的页表中寻找逻辑页号对应的物理页号，



## 第七章-虚拟存储管理

对于一个程序若其大小比内存大，则看似无法将其全部装入内存中运行。为了解决这个问题我们提出了虚拟存储系统，即将部分内容装入外存中，必要时实行动态调入与淘汰。

### 虚拟页式存储管理：

当访问的页不在内存中时，通过直接写入或淘汰将该页装入内存。我们需要给页表增加内外标识表明某页所在物理位置，快表增加修改标识，他只用记录在内存的页的页框号。

内存页框分配策略：平均分配，按进程长度分配（分配数=程序长度/总长度*页框数），按优先级利分配，按长度和优先级别比例分配。

外存块的分配策略：静态分配（外存保持进程的全部页面，更常用），动态分配（外存仅保持进城不在内存的页面）

页面调入时机：请调（发生缺页中断时调入），预调（将要访问时调入）

颠簸：页面在内存和外存之间频繁换入换出。

工作集：进程在一段时间（窗口尺寸）内所访问的页面的的集合。
若窗口尺寸过小，则容易导致页故障率高。
若窗口尺寸过大，则导致内存浪费。
我们可以建立反馈模型改善这一点，若页故障率高就增加内存页面，反之减少。

### 虚拟段式存储系统

动态链接：
对于一个段而言，在初次使用它时，将其从文件中读入内存与外存中，为其段名分配一个段号。

存在的问题：
动态链接需要修改代码，这对于共享而言是不能忍受的，因而我们将代码分为纯段与杂段，前者不可修改可共享，后者反之。

### 虚拟段页式存储系统

增加了共享段表存放纯段，但使用它需要从段表访问它。

### 置换算法

最佳淘汰算法：淘汰将来最长时间以后才用到的（不可实现）

先入先出：淘汰最先调入的，会产生belady异常，即刚淘汰的就被调用

最近最少使用算法（LRU）：淘汰最近一次访问距当前时间最长的。用栈实现，访问时将元素从栈中取出放在栈顶。

最近不用的先淘汰、最不经常使用的被淘汰，最频繁使用算法

二次机会：淘汰装入最久且最近未被访问的页面

时钟算法：环形遍历每个内存页面，淘汰时按顺序查找当前指针后第一个没被访问过的的页面。

## 第八章-文件管理

文件：具有符号名并且在逻辑上具有完整意义的信息项的序列
文件系统：文件与管理文件的程序的集合

UNIX文件分裂：
普通文件，目录文件，特殊文件（设备）

文件的访问方式：
顺序访问、随机访问

文件的组织：
逻辑组织：用户看到的文件组织形式
物理组织：逻辑组织到磁盘块的映射

文件的物理组织：
考虑因素：记录格式，空间开销，访问速度，长度变化。
顺序结构、链接结构、索引结构、哈希结构

文件共享：
公共目录（都能访问的目录）、共享说明（都能访问的文件）、连接（不同用户经过不同文件名访问同一文件）

文件保护：
存取控制矩阵：建立每个文件对每个用户的权限说明
访问权限说明：给用户分为拥有者，同组用户，其他用户，让文件记录每种用户的权限。

文件系统保密：口令与key

文件安全：
海量转储：定期全转储
增量转储：只复制修改部分

文件系统：
系统打开文件表：记录FCB主部、文件号、共享计数、修改标志
用户打开文件表：记录打开方式、读写指针、系统打开文件表入口
最后形成连接结构，对每个用户打开文件表的表项都指向系统打开文件表的表项，

外存管理：
超级块：存有一百个文件块的指针与空闲文件块的计数
文件块指针：
	对于0指针，其指向另一个存储起来的超级块
	对于其余指针都指向空闲块
若无剩余空闲块则将0指针指向的块读取至内存
若剩余空闲块溢出则将自己写入外存并让0块指向自己

文件界面此略

## 第九章-设备与IO管理

设备分类：
	用途：存储型、IO型、网络设备
	管理：共享性、独占型(块型、字符型)

磁盘：
	考虑读写延迟，逻辑上相邻若物理上相邻可能导致无法连续读取
	寻道时间T=mn+s(n为跨越磁道数，m是跨越一个磁道所用时间，s为启动时间)
	旋转延迟T=1/(2r)r为转速，大致为旋转半周的时间
	传输时间T=b/(rN)r为转速b为读写字节数N为磁道上的字节数
	当对象为扇区是，一个扇区的访问时间是T=1/rM,M为扇区数

I/O传输方式：
	程序查询方式：CPU反复询问设备I/O是否完成。
	中断驱动方式：设备工作完成时，打断CPU。
	DMA：占据总线实现数据传输。
	通道：可编程。（字节多路、数组选择、数组多路）

磁头引臂调度：
	先到先服务：谁先提出申请先读取谁
	最短寻找时间优先：先到当前方向上最近的
	scan：增加一个引臂，用于查找当前方向是否有请求。
	C-SCAN：查找到头时回到另一头继续单向服务。
	N步扫描：将请求队列分为若干个长度为N的请求队列，队列内部采用SCAN。
	FSCAN：将请求分为两批，在进行前一批服务的同时为后一批请求进行扫描。完成后交换两个队列的地位。

缓冲池管理：
	输入设备：
		进程		
		① IO链空？若是转②，若否转⑤
		② 设备忙？若是转④，若否转③
		③ 申请空缓存，启动设备，转④
		④ 等待，转⑤
		⑤ 取缓冲，信息进入进程，释放空缓冲
		中断
		① 缓冲入IO链，转②
		② 有等待进程？若是转③，若否唤醒后转③
		③ 传输完毕？若是返回①，若否申请空缓冲，启动设备。
	输出设备：
		进程
		① 申请空缓冲，信息进入缓冲
		② 设备忙？若是转④，若否转③
		③ 启动设备，转⑤
		④ 缓冲入IO链
		⑤ 传输完？若是结束，若否转①
		中断
		① 释放空缓冲
		② IO链空？若是转④，若否转③
		③ 去一缓冲，启动设备
		④ 结束

RAID:
用多个磁盘实现高速运输的技术。
raid级别：行业标准
raid分条：位级分条、块级分条
raid衡量指标：速度、可靠性、成本

level0:数据分条以块为单位, 连续的数据条循环存放在多个磁盘上。

level1:数据分条以块为单位, 采用分布镜像方式存储, 即完全相同的数据重复存放在两个盘上.。

level2:数据以位(bit)为单位分条, 分布存放在多个数据磁盘上, 汉明纠错码存放在纠错磁盘上。

level3:数据以位(bit)为单位分条, 分布存放在多个数据磁盘上;只用一个冗余磁盘存放奇偶校验位。

level4:数据分条以块为单位, 用异或运算产生校验信息, 校验信息保存在单独的磁盘上。

level5:数据分条以块为单位, 异或校验信息分散循环保存在各磁盘上。

虚拟设备：
总体思路上与虚拟存储相同，但用于实现的设备上没有性能区别，相当于人为的将x个设备视作y个设备（y>x），多出来的虚拟设备的工作也需要实设备完成。

稳定存储器：通过冗余来确保信息不丢失