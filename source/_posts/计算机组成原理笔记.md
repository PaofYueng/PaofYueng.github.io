---
title: 计算机组成原理笔记
date: 2019-10-15 18:01:28
tags: 
- 课程笔记
mathjax: true
---

# 计算机组成原理

## 前言

​		一个学渣的自我挣扎。本文不全

<!-- more -->		

## 第一章 计算机概述和技术

### 程序概念入门

软件 = 程序+文档 = 数据结构+算法+文档。

程序语言: 机器语言、汇编语言、高级语言

### 硬件

冯诺依曼模型

2. 五大部件：存储器、运算器、控制器、输入、输出。
3. 控制器：取指令->分析指令->执行指令。

### 性能
1. 性能最终的判断依据为执行时间。但在面对诸如 “性能提升了x%” 的描述时不能简单地如此运算 $ T\times(1-x\%) $。性能增加的比例并不直接等同于运行时间减少的比例，打个比方，性能在日常语境中应该类似于速度，速度越快，运行时间越短。所以在此描述中应当最终运行时间应当为$ \frac{T}{1+x\%} $。
2. 性能的直接影响因素有:指令数目、CPI、时钟周期时间。三者的乘积即为最终运行时间。
3. 同一条指令在不同的指令集下可能有不同的执行方式，可能会出现出现不同数目的子指令共同构成一条指令的情况。 故而不同指令集下的指令数目会不同，影响最终运行时间。
4. MIPS(每秒百万条指令)：$MIPS=\frac{指令条数}{执行时间\times10^6}=\frac{指令条数}{指令条数\times CPI\times时钟周期秒数\times10^6}=\frac{时钟周期}{CPI\times10^6}$可见其与时钟周期与CPI有关，但在不同的程序中CPI不尽相同，所以很难描绘出计算机的性能差距。



## 第二章 计算机语言

### 前言

​		在二进制的机械语言之上，还存在汇编语言，此书中的汇编语言选用的是MIPS。

### 寄存器

| 32个32位寄存器 | 存储寄存器功能 |
| :--------: | :------------: |
| \$s0-\$s7  |    存储数值    |
| \$t0-\$t9  | 临时存储 |
|   \$zero   | 永久存储0 |
| \$a0-\$a3  | 函数参数 |
| \$v0-\$v1  | 函数返回值 |
|    \$gp    | 全局指针 |
| \$fp|帧指针|
| \$sp|堆栈指针|
| \$ra|返回地址|
| \$at|调用以实现大实数|

### 存储器 

即内存，用于存储更多数据，通过地址偏移量来确定存储地址有$2^{30}$个bit。

### 指令

有三种指令类型：R、I、J。后会专门详细说明。

### 数字编码

|   编码方式   |   正数表示   |   负数表示   |
| ---- | ---- | ---- |
| 原码 | 第一位符号位为0 | 第一位符号位为1 |
| 反码 | 直接储存 | 取反 |
| 补码 | 直接储存 | 取反加一 |
| 移码 | 补码符号位取反 | 补码符号位取反 |

移码中如8位存储器中，正负数编码都为真值+127。

符号扩展：正数前端加0，负数前端加1。

### 寻址模式

| 寻址模式   | 参数个数与种类   | PC地址                    |
| ---------- | ---------------- | ------------------------- |
| 立即数寻址 | 一个立即数       | 立即数                    |
| 寄存器寻址 | 一个寄存器       | 寄存器所储存的地址        |
| 基址寻址   | 一个16位数a      | PC+a（经符号扩展为36位）  |
| PC相对寻址 | 一个16位数offset | PC+offset*4               |
| 伪直接寻址 | 一个26位数offset | PC高4位连接offset左移两位 |



## 第三章  计算机的算术运算

### 整数

#### 整数的加减法

​		整数采用补码存储，可直接进行加减运算。

##### 检测溢出

1. 单符号位：两个正数相加符号位为1溢出，两个负数相加符号位为0溢出。
2. 双符号位：数据存储范围较单符号位小，但可判断溢出方向。正数符号位为00，负数符号位为11，当符号位为01时为正溢，10时为负溢。

#### 整数乘法

1. 原始：

   通过同时左移被乘数，右移乘数来实现，如果乘数的最末位为1则乘积加上被乘数。

2. 改进

   乘积位数为被乘数的两倍，初始状态乘积高半部分为0，低半部分为被乘数。求积过程为：①若被乘数末位为1，则乘积的高半部分加上乘数，若非不操作。②右移被乘数。相当于将左移的过程反向进行。

#### 整数除法

​	相当于乘法的逆操作，不过是相减后要判断是否小于0，若是则返回原值。

### 浮点数

#### 存储方式

将二进制数转化为$\pm1.xxxx\times2^{yyyy}$的形式将符号、x、y的部分存储下来。在IEEE754中，单精度下有一位符号位、8位指数位、23位尾数位。双精度下1位符号位、11位指数位、52位尾数位。指数部分按补码方式存放。

#### 浮点数加减法

1. 小指数对大指数
2. 运算
3. 规格化

## 第四章 处理器

### 指令类型

1. R型指令：op(6 bit)+rs(5 bit)+rt(5 bit)+rd(5 bit)+shamt(5 bit)+funct(6 bit)
2. I 型指令：op(6 bit)+rs(5 bit)+rt(5 bit)+address(16 bit)
3. J型指令：op(6 bit)+address(26 bit)

op用于控制CU，rs/rt/rd，为寄存器地址，shamt用于逻辑运算中，funct用于控制ALU，address为存储器地址。

### 主控制单元信号

| 信号     | 功能                  |
| -------- | --------------------- |
| RegDst   | 选择写入寄存器        |
| Branch   | 控制分支结构          |
| MemRead  | 控制读取内存          |
| MemtoReg | 控制内存写入寄存器    |
| ALUOp    | 控制ALU Control       |
| MemWrite | 控制写入内存          |
| ALUsrc   | 控制ALU第二元数据来源 |
| RegWrite | 控制寄存器写入        |
| Jump     | 控制PC跳转            |

### 指令的实现

#### R型

1. R型中共有三个寄存器，分别是二个运算元与一个写入寄存器，故RegDst中要选择中第三个寄存器，置1。
2. R型与分支结构无关，不影响PC，故Branch置0。
3. 整个运算中既不需要暂存入内存，也不需要从内存中读取数据，故MemRead、MemtoReg、MemWrite置0。
4. 根据具体操作不同ALUOp不同。ALU的第二元为存储了第二个运算元的寄存器，故ALUsrc置0。
5. 需要写入第三个寄存器，RegWrite置1。

#### I型

##### 读取指令

1. I型有两个寄存器都为读取寄存器，故RegDst置0。
2. 读取指令与分支结构无关，Branch置0。
3. 需要读取内存，MemRead置1。
4. 读取需要将其存入寄存器，故MemtoReg，RegWrite置1。
5. 不需要写入内存，MemWrite置0。
6. 二元ALU的第二元来自地址与rt的加法运算，ALUOp为00，故ALUsrc置1

##### 写入指令

1. I型有两个寄存器都为读取寄存器，故RegDst置0。
2. 读取指令与分支结构无关，Branch置0。
3. 不需要读取内存，不需要存入寄存器，故MemRead、MemtoReg、RegWrite置0。
4. 需要写入MemWrite置1。
5. 二元ALU的第二元来自地址与rt的加法运算，ALUOp为00，故ALUsrc置1。

##### 分支指令

1. I型有两个寄存器都为读取寄存器，故RegDst置0。
2. 为了控制分支结构，Branch置1。
3. 不需要寄存器写入，存储器读写，故MemRead，MemtoReg，RegWrite，MemWrite置0。
4. 二元ALU的第二元来自与rt，rt的加法运算，故ALUsrc置0，分支指令中ALUOp为01。

#### J型

​		只需要Jump信号。

### 单周期设计的问题

1. 时钟周期由执行时间最长的指令决定
2. 单周期指令代价高，违反设计原则
3. 可以通过流水线技术提高性能

### 流水线

#### 目的

 		为解决简单的串行执行指令导致的每一时刻只有一种元器件处于工作状态，而其他元器件都处于空闲的效率低下的问题。实现每个元器件按流水线方式运行。

#### 数据冒险

##### 出现原因

​		当并行处理指令可行后，若后一指令运算元是前一指令的运算结果，则可能出现，前一指令运算结果还未写回寄存器而后一指令已经开始处理运算部分。

##### 解决方案：

		1. 建立数据旁路，在所需数据产生时，将数据送入所需区域。
		2. 指令重排

##### 注意事项

​		在旁路中，由于运算在ALU中完成，故在运算结束后直接送入ALU源，而在对于取数操作，要在内存读取后才能有数据，故而需要等待一个周期，即需要一个气泡。

#### 控制冒险

##### 出现原因

​		在分支来临时并不知道分支结果如何，故而无法分布后续元器件操作。在循环中等待分支结果可能会浪费大量时间。

##### 解决方案：

​		预测分支结果，并安排好后续操作。

#### 流水线数据通路

##### 部件

​		我们于元器件相交处建立新的存储区域，并以其作为数据通路。

​		IF - IM - EX - MEM - WB，五个不同步骤的中间加入寄存器。即IF/IM , IM/EX , EX/MEM , MEM/WB。

##### 数据冒险

转发（基本等同于旁路）

##### 控制冒险

法1：假设分支不产生

法2：预测分支

## 第五章 存储器

### 存储器

1. DRAM 用于主存，需要刷新，用电容存储数据。
2. SRAM 用于cache，不需刷新，用触发器存储数据。
3. 闪存    用于U盘
4. 磁盘    分有磁道和扇区两部分，分开寻址。

### Cache

#### 基本概念

​		为了更加告诉的寻找数据，我们在CPU和内存间建立中转站，用地址映射的方式存储数据。

​		对于这种映射方式，我们一般将地址分为多个部分，分别映射。

#### 块

​		在此章节中，我们将数据分块，即将相邻的数据单位作为一个集合存储。

​		在这么处理后，地址低位一般作为块内偏移，不算做映射的一部分。

#### 直接映射

​		我们将cache中的块编号，编号x的块只会存储块地址低位同为x的数据。这样我们就得到了地址的一部分。而另一部分我们采用最暴力的方法在cache中相应位置存储它，我们称其为标记位（tag）。同时我们仍需一位二进制来表示cache中这一块是否有数据，我们称之为有效位（valid）。

##### 寻址方式

​		对于一个内存地址，我们暂时隐去低位一部分将其化作块地址，我们取块地址低位一部分即

#### 全相联映射

#### 多路组相联

### 虚拟存储技术

#### 基本概念

​		

#### 页与页表

#### 快表







