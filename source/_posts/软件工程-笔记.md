---
title: 软件工程-笔记
date: 2021-05-28 18:59:36
tags:
- 课程笔记
mathjax: true
---

# 前言

> 懒得写了

<!-- more -->		

# 软件工程概论

## 软件

软件：计算机系统中硬件相互依存的另一部分，程序+数据+相关文档。

三个时期：程序设计，程序系统，软件工程

### 软件组成

程序：事先设计的功能和性能要求执行的**指令序列**
数据：程序能正常操纵信息的**数据结构**。
文档：程序开发，维护与使用有关的**图文材料**

### 软件特点

与硬件对比

1. 软件是逻辑实体而非物理实体，因而有抽象性
2. 没有明显的制造国曾，质量控制必须着重于软件开发
3. 软件没有机械磨损老化问题|
4. 维护比硬件更困难
5. 存在退化问题，即随着修改软件失效率逐渐上升

## 软件危机

软件危机是指：在计算机软件的**开发和维护**过程中所遇到的一系列严重问题。

开发：需求增加
维护：数量膨胀的软件

### 软件危机的主要表现

1. 开发成本与进度难以估计，成本占计算机系统总成本上升，开发生产率上升不及计算机应用普及趋势
2. 用户对成品不满意
3. 软件质量低，不可维护，没有适当的文档

### 软件危机的原因

软件本身原因：软件逻辑性，程序的复杂性与规模庞大

开发和维护的原因：

1. 软件定义时期工作不足，尤其是软件需求分析的重要性（早期设计疏忽导致后期问题）
2. 认为软件开发就是写程序（没有工程思想）
3. 轻视软件维护

### 消除软件危机的途径

1. 认识到软件不止程序，而是程序+数据+相关文档
2. 认识到软件开发是群体工作的工程项目
3. 充分借鉴工程学技术
4. 使用软件开发成功的技术和方法（设计模式
5. 开发和使用更好的软件工具（框架

## 软件工程

“软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。”
软件工程=软件开发+工程学+管理学

### 基本原理

1. 分阶段的生命周期计划严格管理
2. 坚持阶段评审（设计错误多余编码错误，错误发现得越晚成本越高
3. 实行严格的产品控制（修改需求需要审核，以确保相关部分也被修改
4. 采用现代程序设计技术
5. 结果应该能清楚的审查（可见性越高越容易管理
6. 开发小组成员少而精
7. 承认不断改进软件工程实践的必要性（总结经验

该做什么（12），怎么做（34），做成什么样（5)，谁来做（6），做完该做什么（7）

软件工程包括管理与技术两方面的内容

软件生命周期全过程使用的一整套的技术方法的集合，称为方法学，也称范型，包括三个要素：方法，工具和过程。
方法：技术方法
工具：开发环境
过程：工程框架

方法学主要有两种，传统方法学与面对对象方法学

传统方法学又称生命周期方法学或结构化方法学，思路在于将生命周期分为若干阶段，越往后工作越细化，每个阶段结束前都需要按照标准技术审查与管理复审

传统方法学的缺陷在于由于吧数据和操作人为分解增加了开发与维护的难度

面对对象方法学将数据与操作紧密联系

4要点

1. 对象融合了数据和数据上的操作
2. 将数据划分为类
3. 类层次关系（继承）
4. 对象间仅能通过发送消息相互联系

面向对象=对象+类+继承+通信

软件工程涉及人员有客户，开发者与用户（客户是软件的需求人，而用户才是真正的使用者

## 软件生命周期

1. 问题定义
2. 问题分析
3. 寻找解法
4. 判定最佳解法
5. 设计规格说明：对解法的细节描述
6. 实现

又或概括地说软件生命周期由软件定义，软件开发，运行维护三个时期

软件定义（前期）

1. 问题定义阶段
2. 可行性研究阶段（是否有解，是否值得解
3. 需求分析阶段（需要实现的功能

软件开发（中期，后期）

1. 总体设计阶段（寻找可能方案，确定最优方案，指定实现详细计划与设计的体系结构
2. 详细设计阶段（设计出详细的规格说明
3. 编码与单元测试阶段（模块
4. 综合测试阶段（集成测试，验收测试

运行维护阶段

1. 改正性维护
2. 适应性维护
3. 完善性维护
4. 预防性维护

# 软件过程

过程：使用资源将输入转化为输出的活动 所构成的系统。包含：一组活动（activities）约束（constraints）资源要素（resources）

软件过程：为建造高质量软件所需完成的任务的**框架**，它规定了完成各项任务的工作步骤

## 瀑布模型

阶段间具有的顺序性和依赖性：前一输出是后一输入

推迟实现：先设计好再去实现

质量保证：每个阶段的文档要分的评审（由于瀑布模型纠错很难

瀑布模型是**文档驱动**的模型 ** 

优点：

1. 规范的方法
2. 必要的文档
3. 充分的评审

缺点：

实现需要完整准确的需求是不现实的，可运行的版本再最后才有因此难以查错

## V模型

编码的同时进行测试，关注点在开发的各阶段的活动，故而是活动驱动的

单元测试和集成测试－>校验程序设计；
系统测试－>校验（verify）系统设计；
验收测试－>确认（validate）需求；

验证（verification）：代码客观能否运行或运行的质量

确认（validation）：是否满足客户与用户主观的需求

需求-实现-交付的抽象更加明显，本质上是吧瀑布模型开发-验证相关性更加明显，但仍然过于理想。

## 快速原型模型

增量模型的一种，优先开发出可以运行的软件原型（demo），使开发人员和用户达成共识。

快速分析-快速构造原型-运行原型-迭代-最终系统

优点：

1. 无反馈环，因为原型构造后就已与用户交互验证了
2. 有利于与用户交流
3. 可以瀑布模型结合，将满意的原型作为瀑布模型的输入

问题：

1. 原型无需面面俱到
2. 不可让客户认为原型是最终版本
3. 开发人员也不可认为原型是最终版本，原型中没有考虑质量
4. 需与客用户达成一致原型只是模型

## 阶段式开发or演化模型

可认为是原型的扩展版，由于需求可能更改，每一次迭代都需要走完(需求->设计->实现->测试->集成)，通过反馈再决定是否再次迭代。

阶段式开发大致分为： 渐增式开发与迭代式开发两种

迭代式开发粒度比增量式开发大

### 增量模型or渐增模型

粒度为增量构件，第一个增量构建往往是软件的基本需求

不断实现其他功能构建直至完成

优点:

1. 适用于人员不足，不能在期限内完成完全版本
2. 有计划地管理技术风险（构件无法实现）
3. 每个增量都发布了一个高质量的可操作版本
4. 逐渐增加产品功能可以使客户有充足的时间学习和适应

问题

1. 增量构件集成到软件体系结构存在困难
2. 体系结构必须开放，增加了设计阶段的投入
3. 软件整体与互相独立的构建序列的矛盾（逻辑上）

不同构件迭代过程可以并行工作，节省时间但增加了风险

### 螺旋模型or迭代模型

每次迭代都需要风险分析-实施工程-客户评估-制定计划，即完成一个完整的demo再进行打磨

优点：

1. 保证质量十分有利，风险分析够多，并由客户保证了阶段性产品质量
2. 由于风险分析，测试活动的确定性增强了
3. 保证了维护得到与开发同样的重视（每次维护均是完整的迭代）

缺点：

1. 由于开发完整原型的时长，主要适合内部开发
2. 由于每个阶段均要风险分析，成本增加，故而只适合大型软件项目的开发
3. 对开发人员的风险分析能力是极大的挑战

## 喷泉模型

面对对象方法学所用到的，即下一个阶段开始同时也需要上一阶段进行精化。

避免让开发过程变得过于无序，需要把一个线性过程作为总目标

## RUP(Rational统一过程)

生命周期是二维的，除了将时间，还有核心工作流

即不同工作流可以很大程度的并行

## 敏捷过程

价值观：

1. 个体和交互胜过过程与工具

   宁缺毋滥，勤开会

2. 可以工作的软件胜过面面俱到的文档

   对于客户可以运行的软件更重要，更易于交流

3. 客户合作胜过合同谈判

   客户长期地参与进开发中

4. 响应变化胜过遵守计划

   客户说改就得改

## 极限编程

极限编程是最常用的敏捷过程，极限编程指把最好的开发时间运用到极致。

特点：

1. 对变化和不确定性反应更快速，更敏捷
2. 快速的同时保持可持续的开发速度

应该做：

1. 持续集成，一天多次集成
2. 可持续的开发速度，不过度加班
3. 开放的工作空间
4. 及时调整计划（灵活
5. 简单的设计（简单的逻辑避免错误
6. 重构（理解成重写代码，理顺逻辑
7. 使用隐喻（讲故事

## 微软过程





# 可行性研究

目的：最小代价，最短时间确定问题能否被解决

实质：压缩简化了的系统分析和设计过程

成本大概为5%~10%

任务：

1. 技术可行性（做得到？
2. 经济可行性（做得起？
3. 操作可行性（交互合理？
4. 法律可行性（版权？
5. 开发方案的选择性研究（择优选用

最根本任务：探讨有无解，探讨较优解

系统流程图：用图形符号以黑盒子形式描绘组成系统的每个部件。包括程序、文档、数据库和人工过程等。它表达了数据在系统各部件之间的流动情况。

## 成本效应分析

估计开发成本，运行费用，与经济效应

成本估计：主要表现为人力成本，可用代码行技术，任务分解技术，自动估计成本技术推算

效益估计：

1. 货币的时间价值，需要考虑通胀 $P=F/(1+i)^n$
2. 投资回收期，累计的经济效应等于最初投资所需的时间，时间越短，越早盈利
3. 纯收入，整个生存周期系统的累计经济效应(考虑通胀)与投资的差
4. 投资回收率，与银行年利率比较，赚的太少等于亏

## 数据流图 DFD

符号：

1. 源点，终点，系统之外的实体，可以是人，物，或其它软件系统，某种意义上表示接口
2. 加工/变换，对数据进行处理的单元，在分层数据流图中要编号
3. 数据流，由数据项组成
4. 文件，数据暂存

分层

1. 顶层，只有可以为复数个的源点终点，与**唯一一个变换**组成（视作黑盒）
2. 0，1，2......

(1)子图的图号就是分解的父图中加工的编号

(2)子图中的加工的编号是由子图号、小数点，局部顺序号组成，例如2.2的子图是2.2.1，2.2.2，......

相当于是上层的某一变化进行细化

平衡：子图和父图的输入输出绝对一致

## 数据字典

数据字典是对数据流图中包含的所有元素的定义的集合
数据词典与数据流图共同构成系统的逻辑模型
数据字典应该由对下列4类元素的定义组成：数据流、数据流分量(即数据元素)、数据存储、处理

DFD中每一个数据流内的数据组成的集合



| 符号       | 含义                   |
| ---------- | ---------------------- |
| =          | 定义为                 |
| +          | 与                     |
| [...,...]  | 或                     |
| [...\|...] | 或                     |
| {...}      | 重复，0~无穷           |
| m{...}n    | 重复，m~n              |
| (...)      | 可选，可有可无         |
| "..."      | 基本数据元素           |
| a..b       | 连接符 [a,b]的任意元素 |

描述方法：

数据元素名：
	类型：数字（离散值，连续值），文字（编码类型）
	长度：
	取值范围：
	相关的数据元素及数据结构

数据文件名：
	简述：存放的是什么数据；
	输入数据；
	输出数据；
	数据文件组成：数据结构；
	存储方式：顺序，直接，关键码；
	存取频率；

加工名：
	加工编号：反映该加工的层次；
	简要描述：加工逻辑及功能简述；
	输入数据流；
	输出数据流；
	加工逻辑：简述加工程序，加工顺序；

若加工由多种分支组成适合建立加工表或判定树来描述加工

# 需求分析

任务：

1. 问题的信息域，建立数据模型（需求操作的对象
2. 定义软件的功能，建立功能模型（要做什么
3. 描述外部事件结果的软件行为，建立行为模型（？？？
4. 对以上模型进行分解，分层

具体点：

确定对系统的综合要求

1. 功能需求
2. 性能需求
3. 可靠性和可用性需求
4. 出错处理需求
5. 接口需求--用户接口需求；硬件接口需求；软件接口需求；通信接口需求
6. 约束--精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台
7. 逆向需求
8. 将来可能提出的要求

具体到做什么：

1. 分析系统的数据要求
2. 导出系统的逻辑模型
3. 修正系统的开发计划

必要性：

1. 在需求过程中会产生很多错误
2. 许多错误并没有在早期被发现
3. 这样的错误是能够在产生的初期被检查出来的
4. 如果没有及时检查出来这些错误，软件费用会直线上升

## 与用户沟通获取需求的方法

访谈
面向数据流自顶向下求精
简易的应用规格说明技术
快速建立软件原型

## 分析建模与规格说明

分析建模：抽象，无歧义的书面描述，由一组图形符号和规则组成（图）

软件需求规格说明：用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。(文稿)

1. E-R图

   概念性数据模型是一种**面向问题**的数据模型，是按照用户的观点对数据建立的模型。它描述了从**用户角度**看到的数据，它反映了用户的现实环境，而且与在软件系统中的实现方法无关。

   数据模型中包含3种相互关联的信息：**数据对象**、数据对象的**属性**及数据对象彼此间相互连接的**关系**、

2. 数据规范化

   1NF~3NF

3. 状态转换图

4. 层次框图

5. Warnier图，树形结构

6. IPO图，分为输入，处理及输出三部分

7. 时序图

## 验证软件需求

1. 一致性：需求间不能存在矛盾，即所有需求必须是一致的
2. 完整性：规格说明书中应该包括所有需求
3. 现实性：所有需求都应该是基本可实现的
4. 有效性：需求是正确有效的，可完成用户面对的问题

# 总体设计

设计阶段可视作是需求到编码的**中间过程**，其中分为总体设计与详细设计，前者注重于**数据结构与系统结构**，后者注重于详细的数据结构与**算法**。

注：此步作为前期工作与后期工作的衔接，是对前期工作的充分肯定的基础上进行的，其主旨在于使后期工作易于开展

总体设计分为两个阶段，系统设计阶段与结构设计阶段。

1. 系统设计阶段：确定系统的具体实现方案；
2. 结构设计阶段：确定软件结构。

## 软件设计过程

1. 设想供选择的方案，以数据流图为出发点

2. 选取合理的方案

   合理的方案应该包括

   1. 程序流程图
   2. 系统物流元素清单
   3. 成本/效益分析
   4. 实现进度计划

3. 推荐最佳方案

   1. 分析员推荐
   2. 用户与技术专家审查
   3. 部门负责人审查

4. 功能分解（粒度为模块）

5. 设计软件结构（模块的层次系统）

6. 设计数据库

7. 制定测试计划

8. 书写文档

9. 审查和复查

## 软件设计原理

### 模块化

模块：可单独命名和可编址的**部分**

模块化：将程序划分为多个模块，每个模块完成一个子功能，模块集成起一个整体，可以完成指定的功能满足客户的需要。

模块与组件：模块是以需求的功能划分的，而组件可以粒度更低。

模块并非越多越好：随着模块数目增加，设计模块间**接口所需要的工作量**也将增加。

好处：

1. 软件结构清晰，容易设计阅读和理解
2. 容易调试，可靠性高
3. 容易修改
4. 容易工程管理

### 抽象

抽象：考虑本质而不考虑细节

软件设计过程是在不同抽象级别考虑和处理问题

软件工程过程的每一步都是对软件解法的抽象层次的一次精化

过程抽象：把完成一个特定功能的动作序列抽象为一个**过程名和参数表**，以后通过指定过程名和实际参数调用此过程。（函数

数据抽象：把一个数据对象的定义抽象为一个**数据类型名**，用此类型名可定义多个具有相同性质的数据对象。（数据结构

### 逐步求精

自上而下

### 信息隐藏与局部化

信息隐藏：模块对不需要的信息不可访问(privacy)，隐藏实现细节(.h)

局部化：关系密切的软件元素，物理地放的靠近(array)

好处：

1. 并行开发
2. 易修改，易测试
3. 易扩充

### 模块独立性

模块独立：每个模块完成一个相对独立的子功能，并且与其他模块的关系很简单，他是模块化，抽象，信息隐藏和局部化的概念的直接结果（综合体现与综合要求）

好处：容易开发，容易测试，容易维护（后期工作的开展）

#### 耦合

不同**模块间**互相依赖的紧密程度

取决于接口的**复杂程度**，进入或访问一个模块的点，通过接口的**数据**

追求低耦合，耦合程度影响可理解性，可测试性，可靠性，可维护性

注：耦合强度在于**依赖**关系的存在与是否访问同一**数据**（需考虑数据的归属）

弱耦合：（以下耦合由弱到强排序

1. 非直接耦合，**没有直接关联**，联系集中于**主程序**的调用
2. 数据耦合，访问另一个模块时，传输的数据是**简单的数据**
3. 标记耦合，访问另一个模块时，传输的数据时**数据结构**

中等耦合：

1. 控制耦合，传输的数据**显式地**影响了另一模块中的分支过程，比如开关，标志，名字。

较强耦合：

1. 外部耦合，一组模块都访问同一**全局简单变量**，而不是通过参数表传递。（extern）

   这会导致无法控制各个部件对全局变量的存取，公共数据名的使用，明显降低了程序的可读性

2. 公共耦合，一组模块都访问同一个**公共数据环境**，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。

   对比外部耦合的缺点，多出了公共数据环境的改变可能影响全局

强耦合：

1. 内容耦合，不可容忍的最高耦合情况，不同模块的内部的内容（代码，数据）出现了耦合
   1. 一个模块直接访问另一个模块的内部数据（public的数据或友元数据）
   2. 一个模块不通过正常入口转到另一个模块内部（go to）
   3. 两个模块有一部分程序代码重迭（汇编中才可出现）
   4. 一个模块有多个入口

#### 内聚

一个**模块内**部各个元素彼此结合的紧密程度

注：内聚程度取决于模块目标完成的功能个数，与是否造成了与其他模块不可避免的耦合，即是否能独立的完成过程。

高内聚（以下内聚由高到底排序：

1. 功能内聚，**独立**完成**一件事**，
2. 顺序内聚，一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常一个处理元素的输出数据作为下一个处理元素的输入数据，（相比过程内聚，对于输入输出加以限制）

中内聚：

1. 通信内聚，如果一个模块内**各功能部分**都使用了**相同的输入数据**，或产生了**相同的输出数据**，则称之为通信内聚模块。

   理解为将一个数据用于不同的过程，或从多个过程组合为一个数据，这种情况体现了**模块存在多个目标**

2. 过程内聚，仅包含**完整功能的一部分**，所以它的内聚度仍较低，造成的模块间的耦合度还是较高（无法独立完成功能）

低内聚：

1. 时间内聚，这种模块大多为**多功能**模块，但模块的**各个功能的执行与时间有关**，通常要求所有功能必须在同一时间段内执行，例如**初始化模块和终止模块**，与逻辑内聚相比，由于在时间上集中，所有内聚程度高一些。

2. 逻辑内聚，把几种相关的功能组合在一起，每次调用时，由传送给模块的判定参数来确定该模块应执行哪一种功能（下文中的事务流中心），比如错误处理模块（多个目标功能选一）

   缺点在于

   1. 不是执行一种功能，而是若干功能中的一种，因此它不易修改；
   2. 调用它时要传递控制参数，形成**控制耦合**；
   3. 将未用的部分也调入**内存**，降低系统效率；

3. 偶然内聚，模块内各部分之间没有联系，或者即使有联系，这种联系也很松散。（没有准确的目的功能）

   比如，不同且无关模块中都调用到了某个模块，这个模块本身是一些没有联系的语句的结合。（仅处于节省内存的目的，盲目使用复用代码外提）

## 启发规则

1. 改进软件结构提高模块独立性

   1. 力求降低耦合提高内聚
   2. 提供反馈
   3. 消除重复功能

2. 模块规模应该适中，过大降低可读性，过小接口开销大

3. 深度宽度扇出扇入都应适当（追求椭圆）

   1. 深度：软件结构中控制的层度
   2. 宽度：软件结构中同层模块总数
   3. 扇出：一个模块直接控制的模块书
   4. 扇入：多少上级模块直接调用它

4. 模块的作用域应该在控制域之内

   作用域：受该模块判定影响的所有模块的集合

   控制域：直接间接从属于模块的子模块的集合

5. 降低模块接口的复杂程度

6. 设计单入口单出口的模块（避免内容耦合）

7. 模块功能应该可以预测 ，避免对模块施加过多限制（同样的输入得到同样的输出）

## 描绘软件结构的图形工具

层次图：用来描绘软件的层次结构。矩形框代表一个模块，方框间的连线表示调用关系

HIPO：层次图加输入／处理／输出图，联系前文中的IPO图

**结构图（SC）**：主要内容也是模块和模块间的调用关系。可加上数据流向

### 面向数据流的设计方法（SD）

变换流：信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫作变换流。（有输入有输出，有输入到输出的变换）

事务流：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类信息流被称为事务流，而该处理T称为事务中心（分支）

变换分析：

此设计方法是在DFD数据流图的基础上，将数据流图转化为系统结构图，称之为变换分析

1. 复查基本系统模型。确保输入输出合理
2. 复查并精化数据流图。数据的变化代表了一次变换
3. 确定数据流图具有变换特性还是事务特性。 
4. 确定输入流和输出流的边界，从而孤立出变换中心
5. 完成“**第一级**分解(first level factoring)“ Cm主控模块，Ca输入模块，Ct变换中心模块，Ce输出模块。(画出雏形)
6. 完成“第二级分解”。即把数据流图中的每个处理映射成软件结构中一个适当的模块。 （按照数据流图增加信息）
7. 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化（改进）

事务分析：

有一个明显的“发射中心”（事务中心）时，还是以采用事务分析方法为宜

事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。

与程序流程图相似。

## 软件体系结构

软件体系结构是对**子系统、软件系统构件以及它们之间相互关系**的描述。

构件：软件系统的一个**封装部分**。（粒度比模块大？

构件分类1：处理元素，数据元素，连接元素
构件分类2：控制器构件，协作者构件......

构件间的关系：连接件（往往是隐式的）

视图：代表一个软件体系结构的**部分方面**，这个部分方面专门显示一个软件系统的**特定属性**。

软件体系结构的视图描述方法之一：

1. 概念上的体系结构：构件、连接器……
2. 模块体系结构：子系统、模块……
3. 代码体系结构：文件、目录、库、包含文件……
4. 执行体系结构：任务、线程、进程……

软件体系结构的视图描述方法之二：

1. 逻辑视图：设计的对象模型或相应的**模型**（如ER图）；
2. 进程视图：**并发和同步**情况；
3. 物理视图：**软件到硬件的映射**及其分布情况；
4. 开发视图：在软件开发环境中的**软件静态组织**；

软件体系结构风格根据软件系统的结构定义了软件系统族。它通过施加于**构件上的限制及组成与设计规则**来表现构件和构件间的关系。(换言之，软件体系结构风格限制了构件的组成与相互间的关系)

每种体系结构风格定义了：

1. 一组构件：完成系统所需的某种功能；
2. 一组连接件：实现构件间的“**通信**、协调和合作”；
3. 约束：定义构件**如何被集成**到一起形成系统；
4. 语义模型：使得设计者能够通过分析系统的构成成分的已知性质而理解系统的整体性质。

### 管道/过滤器风格

每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器（Filters）。（换言之，过滤器同时是变换中心与事务中心）

连接件就象是数据流传输的管道（Pipes），将一个过滤器的输出传到另一过滤器的输入 （管道负责传输数据）

注：该风格有强烈的面对过程的特色

优点：

1. 使得软构件具有良好的隐蔽性和**高内聚、低耦合**的特点；（只传输数据
2. 允许设计者将整个系统的输入／输出行为看成是**多个过滤器的行为**的简单合成；（面对过程
3. 支持软件**重用**。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来；（库
4. 易于维护和增强系统。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉；
5. 允许对一些如吞吐量、死锁等性质的分析；
6. 支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其它任务并行执行。 

缺点：

1. 通常导致进程成为批处理的结构。这是因为虽然过滤器可增量地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个、完整的从**输入到输出**的转换。
2. 不适合**处理交互**的应用。当需要增量地显示改变时，这个问题尤为严重。（不存在刷新机制
3. 因为在数据传输上没有通用的标准，每个过滤器都增加了**解析和合成数据**的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。

### 数据抽象与面向对象风格

数据的表示和相关操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。 

限制：对象数据完成，数据元素隐藏（private

优点：

1. 因为对象对其它对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其使用者。（多态
2. 由于访问数据的操作和数据的绑定使得设计者可将问题分解成一些交互的代理程序的集合。（成员函数

缺点：

1. 为了使一个对象和另一个对象通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象。（必须知道类名
2. 必须修改所有显式调用它的其它对象，并消除由此带来的一些副作用。例如，如果A使用了对象B，C也使用了对象B，那么，C对B的使用所造成的对A的影响可能是料想不到的。（并发的不确定性，引用而非值传递

### 基于事件／隐式调用风格

基于事件的隐式调用（Implicit Invocation）风格的思想是构件不直接调用一个过程，而是**发布或广播一个或多个事件**。
系统中的其它构件为它感兴趣的事件**注册过程**。
当一个事件被发布，系统自动调用在这个事件中注册的所有过程，这样，一个事件的发布就“隐式地”激发了另一模块中的过程。

注：多用于前后端的链接，Handler

该风格的特点：事件的发布者并不知道哪些构件会被这些事件影响。这样不能假定构件的**处理顺序**，甚至不知道**哪些过程会被调用**。（高度分离）

隐式调用风格的优点：

1. 为软件重用提供了强大的支持。当需要将一个构件加入现存系统中时，只需将它注册到系统的事件中。
2. 为改进系统带来了方便。当用一个构件代替另一个构件时，不会影响到其它构件的接口。

缺点：

1. 构件放弃了对系统计算的控制。
2. 数据交换的问题。
3. 既然过程的语义必须依赖于被触发事件的上下文约束，关于正确性的推理存在问题。

### 层次系统风格

层次系统（Layerd System）组织成一个层次结构，每一层为上层服务，并作为下层的客户。 （例如：MVC

层次系统风格的优点：

1. 支持基于抽象程度递增的系统设计；
2. 支持功能增强；
3. 支持重用。

层次系统风格的缺点：

1. 并不是每个系统都可以很容易地划分为分层的模式；
2. 很难找到一个合适的、正确的层次抽象方法。

### 仓库风格

高度中心化，所有数据均在中心处理与储存，例如数据库或语音识别

### 客户/服务器（C2风格）

客户系统请求某个动作或服务，服务器系统响应该请求。

# 详细设计

详细设计阶段的根本目标是确定应该怎样具体地实现所要求的系统。（逻辑上详细理清软件及模块内部设计的细节，着眼于算法

## 结构程序设计

用于实现详细设计的目标

结构程序设计的经典定义如下所述：“如果一个程序的代码块仅仅通过**顺序、选择和循环**这3种基本控制结构进行连接，并且每个代码块**只有一个入口和一个出口**，则称这个程序是结构化的。” （换言之不用GOTO

## 人机交互设计

### 系统响应时间

指从用户完成某个控制动作(例如，按回车键或点击鼠标)，到软件给出预期的响应(输出信息或做动作)之间的这段时间

**两个属性**决定用户体验

1. 长度，相应的时长
2. 易变形，考虑为响应时长的方差应尽可能小

### 用户帮助设施

帮助设施分为集成的和附加的两类

1. 获得帮助的及时性
2. 用户获得帮助的方法
3. 帮助信息的显示方法
4. 从帮助信息返回正常交互
5. 如果组织帮助信息

### 出错信息处理

1. 信息应该用用户**可以理解**的术语描述问题。
2. 信息应该提供有助于从错误中恢复的**建设性意见**。
3. 信息应该指出错误可能导致哪些**负面后果**
4. 信息应该伴随着**听觉上或视觉上**的提示 
5. 信息**不能带有指责色彩**

### 交互界面设计

命令式与UI

1. 美学完整性
2. 界面一致性
3. 直接操作
4. 隐喻
5. 用户控制

## 过程设计技术和工具

表达过程规格说明的工具叫做详细设计工具

注：此处不详细说明，大多内容在此课程前均已详细了解过

1. 程序流程图
2. 盒图
3. PAD
4. 判定表
5. 判定树
6. 过程设计语言，也称伪代码

## 程序复杂程度的定量度量 

用途:

1. 判断错误数量，与开发所需要的工作量
2. 比较算法优劣
3. 作为模块规模的精确限度

### McCabe方法

McCabe方法根据**程序控制流**的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的**环形复杂度**。 

流图（也称为程序图）：实质上是“退化了的”程序流程图，它仅仅描绘程序的**控制流程**，完全不表现对数据的具体操作以及分支或循环的具体条件。

流图中的区域数等于环形复杂度。 
流图G的环形复杂度**V(G)＝E－N + 2**，其中，E是流图中边的条数，N是结点数。
流图G的环形复杂度**V(G)＝P + 1**，其中，P是流图中判断的数目，多分支的P=分支数 - 1。

用途

1. 判断控制流与程序结构的复杂程度
2. 对测试难度的定量度量，也是对软件最终可靠性的某种预测
3. 环形复杂度大于10，测试将变得非常困难

缺点

1. 忽视了不同控制流的复杂性的区别
2. 简单IF与循环的复杂度同等看到
3. 嵌套IF与简单CASE复杂性是一样的
4. 模块间接口当作简单分支处理
5. 顺序语句忽视行数复杂度相同

# 实现

编码和测试统称为实现

## 编码

编码就是把软件设计结果翻译成用某种程序设计语言书写的程序。（代码上实现详细设计

**程序设计语言的特性**和**程序设计风格**会深刻地影响软件的质量和可维护性。

### 编码风格

1. 程序的内部文档

   标识符：取个好名字

   视觉组织：空格空行缩进

   注释：

   1. 序言性注释：模块的整体说明（功能，接口，算法，数据，简历等
   2. 功能性注释：程序段的功能

2. 数据说明

3. 语句构造

   语句构造力求简单、直接，不能为了**片面追求效率而使语句复杂化**。

   不要语句嵌套，条件嵌套，循环嵌套，表达式多加括号

4. 输入／输出方法

   1. 对所有的输入数据都要进行检验，识别错误的输入，以保证每个数据的**有效**性；
   2. 检查输入项的各种重要组合的合理性，必要时报告输入**状态**信息；
   3. 使得输入的步骤和操作尽可能简单，并保持**简单的输入格式**；
   4. 输入数据时，应允许使用**自由格式**输入；
   5. 应允许**缺省值**；
   6. 输入一批数据时，最好使用**输入结束标志**，而不要由用户指定输入数据数目；
   7. 在交互式输入输出时，要在屏幕上使用提示符   明确提示交互输入的请求，指明可使用选择项的**种类和取值范围**。同时，在数据输入的过程中和输入结束时，也要在屏幕上给出状态信息；
   8. 当程序设计语言对输入／输出格式有严格要求时，应保持**输入格式与输入语句要求的一致性**；
   9. 给所有的**输出加注解**，并设计输出报表格式。输入／输出风格还受到许多其它因素的影响。如输入／输出设备（例如终端的类型，图形设备，数字化转换设备等）、用户的熟练程度、以及通信环境等。

5. 效率问题

   算法效率，存储器效率，I/O效率（保证可读性下

## 软件测试基础

测试是程序的执行过程，目的在于**发现错误**；
一个好的测试用例在于能**发现至今未发现的错误**；
一个成功的测试是发现了至今未发现的错误的测试。

准则：

1. 所有测试都应该能追溯到**用户需求**。（目标是用户需求 
2. 应该远在测试开始之前就制定出**测试计划** 。
3. 把Pareto原理应用到软件测试中。Pareto原理说明，测试发现的错误中的80％很可能是由程序中20％的模块造成的。 （错误很集中
4. 应该从“小规模”测试开始，并逐步进行“大规模”测试。 （有小到大
5. **穷举测试是不可能的。 **
6. 为了达到最佳的测试效果，（也即最大可能地发现错误）应该由独立的**第三方**从事测试工作。

黑盒测试：不考虑内部实现，只考虑功能

接口上进行测试，主要为了：

1. 是否有不正确或遗漏了的功能？（功能完整？
2. 在接口上，输入能否正确地接受？能否输出正确的结果？（功能实现？
3. 是否有**数据结构**错误或外部信息(例如数据文件)**访问错误**？
4. **性能**上是否能够满足要求？
5. 是否有**初始化或终止性错误**？

白盒测试：已知内部实现，推导出测试方案（结构程序设计的延展

测试着眼于：路径，判断，边界

1. 模块测试（单元测试）：
   把每个模块作为一个单独的实体来测试，发现的往往是**编码和详细设计的错误**。
2. 子系统测试（集成测试）：
   把经过单元测试的模块放在一起形成一个子系统来测试，着重测试**模块的接口**。
3. 系统测试（集成测试）：
   把经过测试的子系统装配成一个完整的系统来测试。发现的往往是**软件设计中的错误**，也可能发现**需求说明中的错误**。  
4. 验收测试（确认测试）：
   把软件系统作为单一的实体进行测试，是在**用户积极参与下**进行的，而且可能主要使用实际数据（系统将来要处理的信息）进行测试。
   目的是验证系统确实能够**满足用户的需要**。
   发现的往往是系统**需求说明书中的错误**。 

此处四个测试对应着详细设计，总体设计与需求分析，呼应前文的V模型。

## 单元测试

最小粒度的测试，着眼于模块的功能与模块的接口

**测试重点**

1. 模块接口（参数表
2. 局部数据结构（说明，初始化，默认值
3. 重要的执行通路
4. 出错处理通路（catch
5. 边界条件

代码审查：人力审查，不可编写者自己检查

###  计算机测试

驱动程序：接受测试数据，传送给被测试模块并接受返回数据
存根程序：“虚拟子程序”，替代被测模块的子程序。

编写驱动程序和存根程序是软件测试活动中**不可避免的一种工作开销**。
为减少这种开销，可以采用渐增式测试方法，在集成测试的过程中同时完成对单一模块的详尽测试。
**模块内聚度高**可以简化单元测试过程。（减少驱动与存根程序）

## 集成测试

集成测试是测试和组装软件的系统化技术。

非渐增式测试：先分别测试每个模块，再一下子把所有模块按设计要求放在一起结合成所要的程序。
先单元后集成

渐增式测试：把下一个要测试的模块同已测试好的那些模块结合起来进行测试，依次类推，每次增加一个模块。这种方法实质上**同时完成单元测试和集成测试。**
边单元边集成

**一次性集成**，当所有组件都单独测试完毕之后，将它们一次性混合起来组成最终的系统，查看其是否能够运行成功。

缺点：

1. 大量的存根与驱动
2. 难以查错
3. 难以区分接口错误与其他类型的错误

**自顶向下集成**，从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来，可深度优先，也可广度优先

优点：

1. 在早期，对主要的控制和关键的抉择进行检验
2. 不需要驱动程序
3. 采取深度优先，可在早期完成并验证一个完整的功能

缺点：

1. 需要并可能需要大量存根程序
2. 由于自顶向下不可避免的需要下层的处理，但因此无法测试下层往上的数据流

**自底向上集成**

自底向上测试从“原子”模块(即在软件结构最低层的模块)开始组装和测试

优点：

1. 不需要存根程序
2. 测试驱动程序的书目较少（可以逐级往上累加）

缺点：

1. 对顶层组件测试得较晚，会推迟主要错误的发现
2. 顶层组件通常控制或影响计时，当系统的大部分处理都依赖于计时时，很难自底向上进行测试。（？

**三明治集成**

将自顶向下策略与自底向上策略结合起来，在顶层使用自顶向下方法，而在较低的层使用自底向上方法。要求选取基准层

优点：

1. 在测试早期就进行了集成测试
2. 结合了自顶向下与自底向上的优点

缺点：在集成之前没有彻底地测试单独的组件。

回归测试：是指重新执行已经做过的测试的某个子集，防止修改造成意外的影响

回归测试集（已执行过的测试用例的子集）包括下述3类不同的测试用例：

1. 检测软件**全部功能**的代表性测试用例；
2. 专门针对**可能受修改影响**的软件功能的附加测试；
3. 针对**被修改过的软件成分**的测试。

## 确认测试

确认测试也叫验收测试，其目标是验证软件的**有效性**。

软件有效性的简单定义：如果软件的功能和性能**如同用户所合理期待**的那样，软件就是有效的。（标准是需求规格说明书，应以用户为主进行

Validation：确认指的为了保证软件确实满足了**用户**需求而进行的一系列活动（用户主观地认可了完成的**结果**

Verification：验证指的是保证软件正确地实现了某个特定要求的一系列活动（客观地正确的完成功能

范围：

1. 保证软件能满足所有**功能**要求。
2. 能达到每个**性能**要求。
3. **文档资料**是准确而完整的。
4. 应该保证软件能满足**其他**预定的要求（例如，安全性、可移植性、兼容性和可维护性等）。

软件**配置**复查：

复查的目的是保证**软件配置的所有成分**都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。（ 文档+程序+数据
在确认测试过程中应该严格遵循用户手册及其他操作程序的说明和要求，从而检验用户使用手册的完整性和正确性。

Alpha和Beta测试

A测在开发者指导下进行，B测在开发者不在的情况下进行。

## 白盒测试

### 逻辑覆盖

语句覆盖：使得每一**可执行语句**至少执行一次。
不考虑分支，只考虑语句块

判定覆盖：每个判定的每个分支都至少执行一次。
全真，全否

条件覆盖：每个条件的可能取值至少执行一次。通常比判定覆盖强 ,但也可能满足条件覆盖标准而并不满足判定覆盖标准
分别罗列各点对**各个变量**的条件并尽可能求**交集**（对相同变量分类，而非对于表达式分类

判定/条件覆盖：判定表达式中的每个条件都取到各种可能的值。同时满足两者

条件组合覆盖：每个判定中条件的所有可能组合至少出现一次。（最强
若某个表达式中若为n个判断的交或并，则一般产生$2^n$个区间，罗列每点产生的区间，并尽可能求交

注：以上五种是以程序流程图以基准考虑的，以下三种是以程序流图考虑的。

点覆盖：至少经过流图的每个结点一次，点覆盖标准和语句覆盖标准是相同的。 

边覆盖：使得程序执行路径至少经过流图中每条边一次，通常边覆盖和判定覆盖是一致的。 

路径覆盖：每条可能路径都至少执行一次(如果程序图中有环，则要求每个环至少经过一次) 。 $2^n$

### 控制结构测试

控制结构测试是根据程序的**控制结构设计**测试数据的技术

1. 基本路径测试

   流图-环形复杂度-独立路径-测试用例

2. 条件测试

3. 循环测试

## 黑盒测试技术

目标：

1. **功能**不正确或遗漏了功能；
2. **界面**错误；
3. **数据**结构错误或外部数据库访问错误；
4. **性能**错误；
5. **初始化和终止**错误。

### 等价划分

所有可能的输入数据，即程序的输入域划分成若干部分，据此导出测试用例，假设相同类别的测试数据作用相同

有效等价类：是指对于程序的规格说明来说，是**合理的，有意义的**输入数据构成的集合。（程序期望的
无效等价类：是指对于程序的规格说明来说，是**不合理的，无意义的**输入数据构成的集合。（程序期望外的

划分方法：

1. 规定取值范围，划分一个有效等价类与两个无效等价类（>,=,<)
2. 规定输入值的集合，划分一个有效等价类与一个无效等价类（属于，不属于）
3. 规定输入数据的一组值，对每个输入划分一个有效等价类，另确立一个不允许值的输入值的集合作为无效等价类（例如多选列表）
4. 规定输入数据必须遵守的规则，设立一个有效等价类（符合规则），和若干个无效等价类（从不同角度违反规则）
5. 输入数据为整形，划分出正整数，负整数和零
6. 处理对象是表格，划分空表，非空表

有效的测试用例设计要尽**可能多的**覆盖尚未被覆盖的等价类
无效的测试用例设计每次只能覆盖**一个**无效等价类

做题先圈画出所有限制，在罗列有效等价类，再设计测试样例覆盖

边界值分析：考虑输入输出范围的边界

错误推测法：猜

## 调试

软件调试是在进行了成功的**测试之后**才开始的工作。它与软件测试不同，调试的任务是进一步诊断和改正程序中**潜在的错误**

（debug

蛮干法：暴力

回溯法：从错误的位置逐级回宿

原因排除法

1. 对分查找法
2. 归纳法
3. 演绎法，设想及枚举出所有可能出错的原因

需要考虑：

1. 是否**同样的错误**也在程序其他地方存在?
2. 将要进行的**修改**可能会引入的“**下一个错误**”是什么?
3. 为**防止**今后出现类似的错误，应该做什么?

## 软件可靠性

软件可靠性：是程序在给定的**时间间隔内**，按照规格说明书的规定成功地运行的概率。 
软件可用性：是程序在给定的**时间点**，按照规格说明书的规定，成功地运行的概率。

稳态可用性
$$
A_{ss} = \frac{T_{正常运行}}{T_{总时间}}\\
A_{SS} = \frac{MTTF}{MTTF+MTTR}
$$
平均无故障时间MTTF，成功的运行的平均时间

平均维修时间MTTR，修复一个BUG平均的时间

### 估计平均无故障时间

$$
E_T:测试之前程序\underline{错误总数}\\
I_T:程序长度\\
\tau:测试时间\\
E_d(\tau):0 - \tau发现的错误\\
E_c(\tau):0 - \tau改正的错误\\
\underline{失效率正比于软件中剩余的(潜藏的)错误数}\\
而平均无故障时间\underline{MTTF与剩余的错误数成反比}\\
平均无故障时间与\underline{单位长度程序中剩余的错误数成反比}\\
\therefore MTTF=\frac{1}{K(E_T/I_T-E_C(\tau)/I_T)}\ \ \ \ \ \ （K一般取200）
$$

估算错误总数

1. 植入错误法，类比标记重捕法。
   $$
   N_S: 人为植入的错误,n:测试发现的原有错误,n_s测试发现的植入错误\\
   \bar{N} =\frac{n}{n_S}N_S
   $$
   
2. 分别测试法，也类似与标记重捕法，两人相同的视为被标记的
   $$
   B_0:错误总数,B_1:测试员甲发现的错误,B_2:测试员乙发现的错误,b_c:两个测试员发现的相同错误\\
   \bar{B_0}=\frac{B_2B_1}{b_c}
   $$

# 软件维护

软件**已经交付使用之后**，为了改正错误或满足新的需要而**修改软件**的过程。

1. 改正性维护（Corrective maintenance）：开发期间的错误
2. 适应性维护（Adaptive maintenance）：运行环境的改变
3. 完善性维护（Perfective maintenance）：增加功能
4. 预防性维护（Preventive maintenance）

特点：

1. 贵
2. 有无软件配置（结构化与非结构化维护）差别巨大
3. 生产率大幅下降

## 过程

1. 首先**建立**维护**组织**；
2. 申明提出维护申请**报告**的过程及**评价**的过程；
3. 为每一个维护申请规定标准化的**事件序列**；
4. 建立适用于维护活动的**记录保管**过程以及规定**复审标准**。

维护报告：

1. 维护要求表或称软件问题报告表
2. 软件修改报告，指明工作量，维护要求的性质，优先级，修改相关的事后数据

维护的事件流：

1. 修改软件**设计**
2. 复查
3. 对**源程序**做必要的修改
4. 单元测试
5. 集成测试（回归测试）
6. 确认测试
7. 复审等

保存维护记录：总而言之，修改的内容，执行人与相对应的人力成本

评价维护活动：成本与效益

## 可维护性

维护人员理解、改正、改动或改进这个软件的难易程度，取决于文档与可维护性复审

决定因素：

1. 可理解性
2. 可测试性
3. 可修改性
4. 可移植性
5. 可重用性

文档：

​	目标是描述系统的使用方法，安装与管理方法，需求与设计，实现和测试

1. 用户文档

   功能，如何安装，如何使用，参考手册，操作员指南

2. 系统文档

   问题定义、需求说明到验收测试计划这样一系列和**系统实现有关**的文档

可维护性复审：

1. 需求分析阶段的复审过程中，就应考虑可维护性。
2. 设计复审期间，应该从容易修改、模块化和功能独立的目标出发
3. 代码复审，应该强调编码风格和内部说明文档
4. 设计和编码过程中，使用可重用的软件构件
5. 测试结束时，进行最正式的可维护性复审，保证配置便于理解

软件再工程：

以软件工程方法学为指导，对程序全部重新设计、重新编码和测试

1. 库存目录分析，分析已有的所有系统的基本信息
2. 文档重构
3. 逆向工程，从源代码中恢复原先设计结果
4. 代码重构，修改代码
5. 数据重构，修改数据结构
6. 正向工程，改变或重构现有系统，以提高其整体质量

# 软件项目管理

注：这一章节是站在较为宏观的角度看待软件开发，区别上述对软件开发过程中的阶段的详细解释。

## 概述

项目：结果导向的暂时的努力

特征：

1. 独特的
2. 暂时的
3. 要求结果

项目约束：时间、金钱（资源）和质量

项目干系人：既得利益者

关键项目干系人：促成或破坏项目的人

## 成本与工作量估算

### 软件成本

注意：与其他管理活动一样，软件成本估算随着项目的进行需要定期修正

1. 包括维护在内的硬件和软件费用；
2. 工作成本（支付给软件开发人员的费用）；
3. 应用的方法、过程所形成的一部分成本；
4. 使用的工具；
5. 差旅费

### 工作量

软件工作量估算是**预测**构造一个软件系统所需的**总工作量**的过程，工作量估算从**软件规模**的估算入手。

**代码行技术**：这种方法依据以往开发类似产品的经验和历史数据，估计实现一个功能所需要的源程序行数。 
**功能点技术**：看交付的软件的总功能有多少。依赖对软件信息域特性和软件复杂性的评估结果估算软件规模。功能点（FP）和对象点是这种估算中常用的指标。
根据**专家经验**来估算软件工作量

## 进度计划

内容：

1. 罗列项目各阶段
2. 把每个阶段划分成需要完成的活动
3. 描述活动间的关系
4. 估算活动所需时间

出发点：

1. 满足干系人的期望与客户的需要
2. 列出所有的可交付成果
3. 判定必须进行哪些活动以建立这些可交付成果

### 工作分解结构

相当于大纲，具体参照书目。

任务责任矩阵：表示分工与责任，详见书目

优点：

1. 明确了项目范围
2. 确定了项目包含的活动
3. 指明活动对应的里程碑

缺点：

1. 没有指明活动间的相互依赖**关联**
2. 无法表示项目中可以**并行**的部分
3. 还需要其他手段才能产生现实可行的项目进度计划

### Gantt图

优点：直观简明和容易掌握、容易绘制

缺点：

1. 不能**显式地**描绘各项作业彼此间的**依赖关系**
2. 进度计划的**关键部分**不明确，难于判定哪些部分应当是主攻和主控的对象
3. 计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费

### 工程网络 

活动（Activity）：一个活动是项目的一部分，它要耗费一段时间，有开始和结束（边
里程碑（Milestone）：一个里程碑是某个活动完成的标志，它是一个特定的时间点（**点

剩余的与求关键路径完全相同，此处略去。

## 人员组织

为了成功地完成软件开发工作，项目组成员必须以一种有意义且有效的方式彼此交互和通信

### 民主制程序员组

小组成员完全平等，享有充分民主，通过协商做出技术决策。2-8人适宜（n*(n+1)）/2

优点：

1. 组员们对发现程序错误持积极的态度
2. 组员们享有充分民主，小组有高度凝聚力，组内学术空气浓厚，有利于攻克技术难关

### 主程序员组

主程序员组用**经验多、技术好、能力强**的程序员作为主程序员，同时，利用人和计算机在事务性工作方面**给主程序员提供充分支持**，而且所**有通信都通过一两个人**进行

出发点：

1. 软件开发人员多数比较**缺乏经验**
2. 程序设计过程中有许多**事务性的工作**
3. 多渠道**通信很费时间**，将降低程序员的生产率

特点：专业化，层次化

主程序员：管理者的同时是程序员，负责体系设计与其他关键设计，协调成员，复查其他成员的工作，主要负责人。

后备程序员：主程序的替补

编程秘书：负责完成项目有关的全部事务性工作（维护资料文档，原码的编译链接运行）

集中式与分散式的区别在于同层的人员是否存在通信方式

## 配置管理

注：上文所述，软件工程的过程微观来看应当是递增，而配置管理就是让这一递增的变化过程变得可见。（不仅仅是代码的变化管理

配置管理的目的是**针对变化、控制变化**；

软件配置管理的目标是：

1. 标识变更

2. 控制变更

3. 确保变更正确地实现

4. 向其他有关的人报告变更


简言之：软件配置管理是软件系统发展过程中**管理和控制变化**的规范。

软件配置管理（Software Configuration Management）是一门应用技术、管理和监督相结合的学科，通过**标识和文档来记录配置项的功能和物理特性、控制这些特性的变更、记录和报告变更的过程和状态，并验证它们与需求是否一致**。（配置文档记录配置项的细则内容

软件配置项（Software Configuration Item） ：为了配置管理而作为单独实体处理的**一个工作产品或一段软件**，简称SCI。
软件配置项：简单说，就是软件过程输出的**全部计算机程序、文档、数据**。
配置管理聚集：SCI的一个组合。简称CM聚集。
版本：在一确定的时间点上，某个SCI或某个配置的状态。

需要保证软件配置项的正确性与一致性

基线（baseline）：IEEE把基线定义为：已经通过了**正式复审的规格说明或中间产品**，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它。
基线就是通过了正式复审的软件配置项。

项目数据库：

1. 一旦一个SCI成为基线，就被存放到项目数据库中；
2. 项目数据库和变更控制规程相结合，保护着项目的基线；

### 管理过程

版本控制：

变化控制：变化需要评估-审阅-提取修改测试-提交

配置审计：

1. 正式的技术审计（保证可行性
2. 软件配置审计（保证需求被满足

状态报告：（简而言之，变化应当被记录

1. 发生了什么事？
2. 谁做的这件事？
3. 何时发生的？
4. 有什么影响？ 

总结：

1. 软件配置管理是一个相对独立的管理活动。 （与其他管理是并行的
2. 其他许多的管理活动，多数都要以完善的配置管理作为基础。 
3. 从实际经验的总结来看，配置管理是诸多管理活动中最易操作、最容易实现并且能在项目最先体现出效果的管理手段。

## 风险管理

风险：能造成恶果的有害事件。风险越大一般收益越大

在风险突然变成问题的那一刻，我们说风险“具现”了。这也是**风险转化**的时刻。

**风险识别**

风险类别：项目风险，技术风险与商业风险

核心风险：

1. 进度安排的先天错误
2. 需求膨胀
3. 人员流失
4. 规约崩溃

**风险分析**

风险暴露值 = 风险概率 * 风险影响

**风险规划**

风险优先级划分
制定风险管理对策

**风险控制**

风险规避，风险转移，风险缓解，风险承担

## 质量管理

软件质量：软件与明确地和隐含地定义的**需求相一致的程度**

**软件需求**是度量软件质量的**基础**
指定的开发标准定义了一组指导软件开发的准则
通常有一组没有显式描述的**隐含需求**

质量保证措施

1. 基于非执行的测试（复审或评审）（审查
2. 基于执行的测试（软件测试）（走查
3. 程序正确性证明

## CMM

初始级-可重复级-已确定级-优化级

# 考察重点

## 第1次课 软件工程概述

 



| 1.1 软件                        |                                         |                                                              |
| ------------------------------- | --------------------------------------- | ------------------------------------------------------------ |
|                                 | 什么是软件***                           | 程序+数据+文档                                               |
|                                 | 软件的特点***                           | 抽象，没有明显的制造过程，没有机械磨损，                     |
| 1.2  软件危机***                |                                         |                                                              |
|                                 | 什么是软件危机                          | 开发和维护上的一系列严重的问题                               |
|                                 | 软件危机的主要表现                      | 成本估计不准，用户不满意成品，质量不可靠，不可维护，没有适当的文档，成本上升，生产率提升难以满足现状 |
|                                 | 产生软件危机的原因                      | 逻辑性，复杂性，方法不正确                                   |
| 1.3  软件工程                   |                                         |                                                              |
| 1.3.1  何谓软件工程             |                                         |                                                              |
|                                 | 软件工程的概念***                       | 计算机软件开发与维护的工程学科                               |
|                                 | 软件工程的本质特性                      |                                                              |
| 1.3.2  软件工程的基本原理***    |                                         | B. W. Boeh，分周期的生命周期计划，阶段评审，产品控制（配置），现代程序设计，结果可审查，开发人员少而精，承认不断改进软件工程实践的必要性 |
| 1.3.3  软件工程方法学           |                                         |                                                              |
|                                 | 软件工程方法学三要素***                 | 方法，工具，过程                                             |
|                                 | 传统方法学、面向对象方法学各自的优势*** | 传统：降低开发难度，提高了可维护性，面对对象：数据操作结合，降低复杂性，提高可理解性，简化了开发和维护，促进了软件重用 |
| 1.3.4  软件工程涉及的人员角色   |                                         | 客户，开发者，用户                                           |
| 1.3.5  软件工程与其他学科的关系 |                                         | 计算机科学，数学，管理学，工程学                             |
| 1.4  软件生命周期***            |                                         | 问题定义-可行性研究-需求分析-总体设计-详细设计-实现-测试-维护 |
| 1.4.1  软件开发团队的成员       |                                         | 需求分析师，设计师，测试员，培训人员                         |



 

 

 

 

## 第2次课 软件过程（1）

 



| 2.1 软件过程          |                      |                                                              |
| --------------------- | -------------------- | ------------------------------------------------------------ |
|                       | 何为软件过程***      | 建造高质量软件所需完成的任务的**框架**，它规定了完成各项任务的工作步骤 |
| 2.2  经典软件过程模型 |                      |                                                              |
|                       | 瀑布模型***          | 需求分析-规格说明-设计-编码-综合测试-维护，文档驱动          |
|                       | V模型                |                                                              |
|                       | 原型/快速原型模型*** | 快速分析-构造-运行-评价                                      |
|                       | 阶段式开发           |                                                              |
|                       | 增量模型             |                                                              |
|                       | 螺旋模型***          | 快速原型-规格说明-设计-编码-综合测试，每一步前都需要风险分析 |
|                       | 喷泉模型             |                                                              |



 

 

 

 



## 第3次课 软件过程（2）

 

| 2.3 现代软件过程模型 |                     |                            |                                                              |
| -------------------- | ------------------- | -------------------------- | ------------------------------------------------------------ |
|                      | RUP软件开发生命周期 |                            |                                                              |
|                      |                     | RUP的4大阶段、9种工作流*** | 工作流：业务建模，需求，分析与设计，实现，测试，部署，配置与变更管理，项目管理，环境提供。阶段：初始，精化，构造，移交 |
|                      | 敏捷过程            |                            |                                                              |
|                      |                     | 敏捷过程的价值观***        |                                                              |
|                      |                     | 极限编程的特点             |                                                              |
|                      |                     | 极限编程的有效实践         |                                                              |
|                      | 微软过程            |                            |                                                              |
|                      |                     | 微软软件生命周期           |                                                              |
|                      |                     | 微软过程的不足             |                                                              |

 

 

 

 



## 第4次课 可行性研究（1）

 



| 3.1 可行性研究的任务   |                     |                                                        |
| ---------------------- | ------------------- | ------------------------------------------------------ |
|                        | 可行性研究的目的*** | 用最小的代价，在尽可能短的时间内确定问题是否能够解决。 |
|                        | 可行性研究的实质*** | 就是一次压缩、简化了的系统分析和设计的过程。           |
|                        | 可行性研究的任务*** | 技术，经济，操作，法律的可行性，开发方案的选择性研究   |
| 3.2  可行性研究过程    |                     |                                                        |
| 3.3  系统流程图***     |                     |                                                        |
| 3.4  成本/效益分析方法 |                     |                                                        |



 

 

 

 



## 第5次课 可行性研究（2）

 

| 3.5 数据流图*** |      |
| --------------- | ---- |
| 3.6 数据字典    |      |

 

 

 

 



## 第6次课 软件需求

 

| 4.1 需求分析的任务           |                                                 |
| ---------------------------- | ----------------------------------------------- |
|                              | 需求分析的任务***：数据模型，功能模型，行为模型 |
| 4.2 与用户沟通获取需求的方法 |                                                 |
| 4.3 分析建模与规格说明       |                                                 |
| 4.4 实体-联系图              |                                                 |
| 4.5 数据规范化               |                                                 |
| 4.6 状态转换图               |                                                 |
| 4.7 其它图形工具             |                                                 |
|                              | 层次方框图                                      |
|                              | Warnier图                                       |
|                              | 改进的IPO图                                     |
| 4.8 验证软件需求             |                                                 |
|                              | 从哪些方面验证软件需求的正确性***               |
|                              | （完整性、一致性、正确性、可测试性等）          |

 

 

 

 



## 第7次课 总体设计（1）

 

| 5.1 软件设计过程    |                                   |                                                |
| ------------------- | --------------------------------- | ---------------------------------------------- |
|                     | 软件设计过程——开发阶段的信息流*** | 设计-编码-测试                                 |
|                     | 概要设计/详细设计概念***          | 概要：数据结构，系统结构。详细设计：模块的细化 |
| 5.2 软件设计原理*** |                                   |                                                |
|                     | 模块化                            |                                                |
|                     | 抽象                              |                                                |
|                     | 信息隐藏                          |                                                |
|                     | 耦合/内聚（模块独立性）等         |                                                |
| 5.3 启发规则***     |                                   |                                                |
|                     | 模块规模                          |                                                |
|                     | 扇入/扇出                         |                                                |
|                     | 控制域/作用域等                   |                                                |

 

 

 

 



 

## 第8次课 总体设计（2）

 

| 5.4 描绘软件结构的图形工具  |           |
| --------------------------- | --------- |
|                             | 层次图    |
|                             | HIPO图    |
|                             | 结构图*** |
| 5.5 面向数据流的设计方法*** |           |
|                             | 变换流    |
|                             | 事务流    |
|                             | 变换分析  |
|                             | 事务分析  |

 

 

 

 



 

## 第9次课 总体设计（3）

 

| 5.6 软件体系结构 |                           |
| ---------------- | ------------------------- |
|                  | 软件体系结构的概念***     |
|                  | 软件体系结构风格的概念*** |
|                  | 管道-过滤器风格***        |
|                  | 数据抽象与面向对象风格    |
|                  | 隐式调用风格***           |
|                  | 层次系统风格***           |
|                  | 黑板/仓库风格***          |
|                  | 客户-服务器风格***        |

 

 

 

 



## 第10次课 详细设计

 



| 6.0 详细设计概要              |               |
| ----------------------------- | ------------- |
| 6.1  结构程序设计***          |               |
| 6.2  几个人机界面设计相关问题 |               |
| 6.3  过程设计技术和工具***    |               |
| 6.4  程序复杂程度的定量度量   |               |
|                               | 流图***       |
|                               | McCabe方法*** |



 

 

 

 



## 第11次课 编码

 

| 7.1 程序设计语言 | 7.1 程序设计语言 |
| ---------------- | ---------------- |
| 7.2 编码风格***  | 7.2 编码风格***  |

 

 

 

 



## 第12次课 软件测试（1）

 

| 7.3 软件测试基础 |                          |
| ---------------- | ------------------------ |
|                  | 软件测试的目标***        |
|                  | 软件测试的准则           |
|                  | 软件测试方法***          |
|                  | 软件测试步骤***          |
|                  | 软件测试与开发过程的关系 |
|                  | 测试阶段的信息流程       |
| 7.4 单元测试     |                          |
|                  | 单元测试的测试重点***    |
|                  | 代码审查                 |
|                  | 计算机测试               |
|                  | 驱动程序和存根程序***    |
| 7.5 集成测试     |                          |
|                  | 4种集成测试策略***       |
|                  | 回归测试***              |

 

 

 

 



## 第13次课 软件测试（2）

 

| 7.6 确认测试     |                     |
| ---------------- | ------------------- |
|                  | 确认测试的概念      |
|                  | 确认测试的范围      |
|                  | 验证与确认的概念*** |
|                  | 软件配置复查        |
|                  | Alpha和Beta测试***  |
| 7.7 白盒测试技术 |                     |
|                  | 逻辑覆盖***         |
|                  | 基本路径法***       |

 

 

 

 



## 第14次课 软件测试（3）

 

| 7.8 黑盒测试技术   |                   |
| ------------------ | ----------------- |
|                    | 等价划分法***     |
|                    | 边界值分析***     |
|                    | 错误推测          |
| 7.9 调试           |                   |
|                    | 调试的概念        |
|                    | 区分测试与调试*** |
|                    | 调试过程          |
|                    | 调试方法          |
| 7.10 软件可靠性*** |                   |

 

 

 

 



## 第15次课 软件维护

 

| 8.1 软件维护的定义  |                           |
| ------------------- | ------------------------- |
|                     | 软件维护的定义和类型***   |
| 8.2 软件维护的特点  |                           |
|                     | 结构化维护与非结构化维护  |
|                     | 维护的代价                |
|                     | 维护的问题                |
| 8.3 软件维护过程*** |                           |
|                     | 维护组织                  |
|                     | 维护报告                  |
|                     | 维护的事件流              |
| 8.4 软件的可维护性  |                           |
|                     | 软件可维护性的概念***     |
|                     | 决定软件可维护性的因素*** |
|                     | 可维护性复审***           |
| 8.5 软件再工程过程  |                           |
|                     | 软件再工程的六个环节***   |

 

 

 

 



## 第16次课 软件项目管理（1）

 

| 9.1 软件成本与工作量估算 |                                                              |
| ------------------------ | ------------------------------------------------------------ |
|                          | 软件规模估算的两种方法：代码行/功能点方法各自的优势和区别*** |
|                          | 静态单变量模型                                               |
|                          | 动态多变量模型                                               |
|                          | COCOMO2模型                                                  |
| 9.2 进度计划             |                                                              |
|                          | 工作分解结构                                                 |
|                          | Gantt图的绘制                                                |
|                          | Gantt图的缺点***                                             |
|                          | 工程网络图的绘制***                                          |
|                          | 区分活动与里程碑                                             |
|                          | 计算EET/LET***                                               |
|                          | 关键路径***                                                  |
|                          | 机动时间***                                                  |
| 9.3 人员组织             |                                                              |
|                          | 软件工程的Brooks定律***：增加新人可能会导致项目更加落后      |
|                          | 民主制程序员组的特点、优点                                   |
|                          | 主程序员组的特点、存在的问题                                 |
|                          | 集中式和分散式组织各自适用的情况                             |

 

 

 

 



## 第17次课 软件项目管理（2）

 

| 9.4 软件配置管理   |                                                 |
| ------------------ | ----------------------------------------------- |
|                    | 软件配置管理的概念***：管理和控制变化的规范     |
|                    | 软件配置项的概念***：为了软件配置管理的一个实体 |
|                    | 配置管理聚集                                    |
|                    | 版本的概念                                      |
|                    | 基线的概念***：正式复审的规格说明或中间产品     |
|                    | 项目数据库                                      |
|                    | 配置管理过程的5项任务                           |
| 9.5 软件风险管理   |                                                 |
|                    | 风险识别                                        |
|                    | 风险分析                                        |
|                    | 风险规划                                        |
|                    | 风险控制                                        |
|                    | 软件开发中常见的4种风险***                      |
| 9.6 软件质量管理   |                                                 |
|                    | 软件质量保证的基本措施（走查、审查等）          |
| 9.7 能力成熟度模型 |                                                 |
|                    | 能力成熟度模型的5个级别及相应特点               |

 

 

 

 



## 第18次课 面向对象分析与设计（1）

 

| 10.1 UML可视化建模简介 |                                          |
| ---------------------- | ---------------------------------------- |
|                        | UML描述模型的三种基本词汇                |
|                        | UML的4种要素：结构，行为，组织，辅助说明 |
|                        | UML的4种关系：关联，依赖，泛化，实现     |
|                        | UML1.1版的9种主要图形***                 |
|                        | UML的3种扩展机制                         |
|                        | 用UML描述系统的5个视图（4+1Views）       |

 

 

 

 



## 第19次课 面向对象分析与设计（2）

 

| 10.2 面向对象的需求提取 |                                                              |
| ----------------------- | ------------------------------------------------------------ |
|                         | 用例的概念***：功能描述                                      |
|                         | 参与者的概念                                                 |
|                         | 参与者与用例的关系                                           |
|                         | 用例的描述形式***：名字，actor，入口条件，事件流，出口条件，特殊需求 |
|                         | 场景与用例的关系***：场景是Use Case的真实例子；              |
|                         | 用例间的关系***：关联，泛化，包含，扩展                      |
|                         | 用例的获取步骤                                               |
|                         | 参与对象的确定                                               |

 

 

 

 



## 第20次课 面向对象分析与设计（3）、复习

 

| 10.3 面向对象分析 |                                                              |
| ----------------- | ------------------------------------------------------------ |
|                   | 三种分析类：实体类、边界类、控制类的含义***：实体，记录和维护的信息；边界，系统与外部元素的监护的边界；控制类，用例中行为的协调 |
|                   | 顺序图转述用例                                               |
|                   | 整理分析类                                                   |
|                   | 分析阶段的注意事项                                           |

 

 

考试题型（包括但不限于）

\1.  选择题（单选，没有多选）

\2.  填空题

\3.  判断对错题

\4.  简答题（计算、简答）

\5.  分析题

