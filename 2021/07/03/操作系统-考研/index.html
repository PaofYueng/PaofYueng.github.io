<!DOCTYPE html>





<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="考研真是麻烦的事啊啊啊啊">
<meta name="keywords" content="考研笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-考研">
<meta property="og:url" content="https://paofyueng.github.io/2021/07/03/操作系统-考研/index.html">
<meta property="og:site_name" content="寻求力量之旅">
<meta property="og:description" content="考研真是麻烦的事啊啊啊啊">
<meta property="og:locale" content="zh_CN">
<meta property="og:updated_time" content="2021-12-06T06:12:36.023Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统-考研">
<meta name="twitter:description" content="考研真是麻烦的事啊啊啊啊">
  <link rel="canonical" href="https://paofyueng.github.io/2021/07/03/操作系统-考研/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>操作系统-考研 | 寻求力量之旅</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">寻求力量之旅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">ACM搬砖记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://paofyueng.github.io/2021/07/03/操作系统-考研/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Paof Yueng">
      <meta itemprop="description" content="PAOFBLOG">
      <meta itemprop="image" content="/images/1564282856-carbon.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寻求力量之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">操作系统-考研

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-07-02 20:00:30" itemprop="dateCreated datePublished" datetime="2021-07-02T20:00:30Z">2021-07-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-06 06:12:36" itemprop="dateModified" datetime="2021-12-06T06:12:36Z">2021-12-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>考研真是麻烦的事啊啊啊啊</p>
</blockquote>
<a id="more"></a>        
<h1 id="考纲"><a href="#考纲" class="headerlink" title="考纲"></a>考纲</h1><p>一、总体要求 主要考察学生对操作系统基本概念、原理的理解程度，重点考察操作系统的设计方法与实现技术， 同时能够具备运用所学的操作系统原理、方法与技术分析问题和解决问题的能力。 </p>
<p>二、内容及比例 </p>
<ol>
<li>操作系统的基本概念<br>1) 批处理与多道程序设计<br>2) 分时系统与实时系统<br>3) 操作系统的基本类型与特征<br>4) 并发与并行的概念<br>5) 操作系统的层次结构与功能模块<br>6) 程序的并发执行与顺序执行 </li>
<li>进程管理<br>1) 进程: 进程控制块、进程的几种基本状态与状态转换（进程的创建、进程的终止、进程的 阻塞与唤醒、进程的挂起与激活等）<br>2) 进程的同步与互斥：临界资源、临界区、进程同步与互斥问题、信号量机制以及 P、V 操 作、管程机制<br>3)  进程间通信：进程通信的类型（直接通信和间接通信方式）、消息传递系统中的几个问题、 消息缓冲队列通信机制<br>4) 线程与进程的调度:线程与进程的基本概念，调度的类型、调度队列模型、调度方式、进 程调度算法（先来先服务、短进程优先、时间片轮转、基于优先级的调度算法等）<br>5) 死锁:死锁的基本概念，死锁定理、死锁预防、死锁避免与处理死锁的基本方法、银行家算法<br>6) 综合应用：生产者消费者问题、读者和写者问题、哲学家进餐问题等 </li>
<li>内存管理<br>1) 内存管理的需求：重定位、内存保护、内存共享<br>2) 程序的装入和链接：静态装入和可重定位装入、静态链接、动态链接、运行时动态链接。<br>3) 分区存储管理：分区方式（单一连续分区、固定分区、可变式分区）、分区分配算法（首 次适应算法、循环首次适应算法、最佳适应法、最坏适应法等）<br>4) 段式管理与页式管理：段、页、碎片等基本概念、段式管理与页式管理机制<br>5) 虚拟内存：局部性原理、虚拟内存概念、请求分段与请求分页、段页式管理、段页式地址 结构与地址转换、页面置换算法（OPT、先进先出、LRU、Clock、改进型 Clock 置换）、 抖动 </li>
<li>设备管理<br>1) I/O 系统的：基本概念、I/O 控制方式（程序 I/0、中断、DMA、通道）、相关数据结构、 缓冲管理（单缓冲、双缓冲、循环缓冲、缓冲池）<br>2) 磁盘管理与磁盘调度算法：SSTF 算法，SCAN 算法，CSCAN 算法，N-STEP-SCAN 算法，FSCAN 算法<br>3) 设备分配、设备处理、虚拟设备，Spooling 系统 </li>
<li>文件系统<br>1) 基本概念：文件和文件系统、目录、文件结构的物理结构和逻辑结构（顺序文件、索引顺 序文件、索引文件、HASH 文件）、文件共享（基于索引节点、基于符号链接实现文件共享）<br>2) 外存分配方法：连续分配、链接分配、索引分配<br>3) 目录管理：单级目录、二级目录、多级目录<br>4) 文件存储空间的管理技术：位示图、空闲链表、索引</li>
</ol>
<h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="操作系统的目标与作用"><a href="#操作系统的目标与作用" class="headerlink" title="操作系统的目标与作用"></a>操作系统的目标与作用</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ol>
<li>有效性<ol>
<li>提高系统资源利用率</li>
<li>提升系统吞吐量</li>
<li>方便性</li>
</ol>
</li>
<li>可扩充性</li>
<li>开放性：符合国际标准，兼容性强</li>
</ol>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol>
<li><p>OS作为用户和计算机硬件系统之间的接口</p>
<ol>
<li>命令方式</li>
<li>系统调用方式</li>
<li>GUI</li>
</ol>
</li>
<li><p>OS作为计算机系统资源的管理者</p>
<p>处理器，存储器，I/O设备以及信息</p>
</li>
<li><p>OS实现了对计算机资源的抽象</p>
<p>隐藏硬件细节与功能实现的细节</p>
</li>
</ol>
<h3 id="推动操作系统发展的主要动力"><a href="#推动操作系统发展的主要动力" class="headerlink" title="推动操作系统发展的主要动力"></a>推动操作系统发展的主要动力</h3><ol>
<li>不断提高计算机资源的利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
</ol>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h3><p>此处硬件对应真空管</p>
<ol>
<li><p>人工操作方式</p>
<p>输入-计算-输出</p>
<p>缺点：</p>
<ol>
<li>用户独占全机</li>
<li>CPU等待人工操作</li>
</ol>
</li>
<li><p>脱机输入输出方式</p>
<p>输入设备-外围机-磁盘-主机-磁盘-外围机-输出设备，其中磁盘与外围机可看作I/O缓冲区</p>
<p>优点：</p>
<ol>
<li>减少了CPU空闲时间</li>
<li>提高了I/O速度</li>
</ol>
</li>
</ol>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>此处硬件对应晶体管</p>
<ol>
<li><p>单道批处理系统处理过程</p>
<p>输入设备可以输入作业，监督程序<strong>自动在作业完成后开始下一个作业</strong>，内存中只有一个作业</p>
</li>
<li><p>单道批处理系统的特征</p>
<p>自动性，顺序性，单道性</p>
</li>
</ol>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>此处对应硬件小规模集成电路</p>
<ol>
<li><p>多道程序设计的基本概念</p>
<p>外存中存储多个作业，作业调度程序按一定算法选择若干个作业调入内存。</p>
<p>好处：</p>
<ol>
<li>提高CPU的利用率，<strong>系统在当前程序等待I/O时处理下一个作业</strong></li>
<li>可提高内存与I/O设备利用率</li>
<li>提高系统吞吐量</li>
</ol>
</li>
<li><p>多道批处理系统的优缺点</p>
<ol>
<li>资源利用率高</li>
<li>系统吞吐量大</li>
<li>平均周转时间长</li>
<li>无交互能力</li>
</ol>
</li>
<li><p>多道批处理系统需要解决的问题(对应了本书讨论的问题)</p>
<ol>
<li>处理机管理问题</li>
<li>内存管理问题</li>
<li>I/O设备管理问题</li>
<li>文件管理问题</li>
<li>作业管理问题</li>
</ol>
</li>
</ol>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>机器的分配过程是透明的。每个终端对用户而言就是一台可交互的计算机</p>
<ol>
<li><p>分时系统的产生</p>
<p>用户需求：</p>
<ol>
<li>人机交互</li>
<li>共享主机</li>
<li>便于用户上机</li>
</ol>
</li>
<li><p>分时系统实现的关键问题</p>
<p>注：由于是交互式的</p>
<ol>
<li>及时接受</li>
<li>及时处理，调度的粒度由作业下降至时间片</li>
</ol>
</li>
<li><p>分时系统的特征</p>
<ol>
<li>多路性</li>
<li>及时性</li>
<li>交互性</li>
</ol>
</li>
</ol>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ol>
<li><p>应用需求</p>
<ol>
<li>实时控制，对于采集到的数据的及时处理并控制</li>
<li>实时信息处理</li>
</ol>
</li>
<li><p>实时任务</p>
<p>按任务是否呈现周期性来划分：周期性实时任务，非周期性实时任务</p>
<p>根据对截止时间的要求来划分：</p>
<ol>
<li>硬实时系统：不在规定时间完成会有难以预测的后果</li>
<li>软实时任务</li>
</ol>
</li>
<li><p>实时系统和分时系统特征的比较</p>
<ol>
<li>多路性：体现在对多个数据的处理</li>
<li>独立性：用户服务。信息采集与对象控制的独立性</li>
<li>及时性：截止时间的要求</li>
<li>交互性：只提供特定的专用服务</li>
<li>可靠性</li>
</ol>
</li>
</ol>
<h3 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h3><ol>
<li><p>单用户单任务操作系统</p>
<p>一个用户上机，且只允许用户程序作为一个任务运行</p>
<p>一般都为8bit和16bit机，例如CP/M与MS-DOS</p>
</li>
<li><p>单用户多任务操作系统</p>
<p>一个用户上机，但允许用户把程序分为若干个任务，是他们并发执行</p>
<p>例如：Windows</p>
</li>
<li><p>多用户多任务操作系统</p>
<p>多个用户通过各自的终端使用同一台机器。共享主机系统的各种资源。而每个用户程序又可进一步分为几个任务，是它们能并发执行</p>
<p>例如：UNIX</p>
</li>
</ol>
<h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><ol>
<li><p>并行与并发</p>
<p>并行：一个时刻运行多个程序</p>
<p>并发：一个时间间隔内运行多个程序</p>
</li>
<li><p>引入进程</p>
</li>
<li><p>引入线程</p>
</li>
</ol>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>系统资源供多个并发执行的进程共同使用</p>
<ol>
<li><p>互斥共享方式</p>
<p>把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源</p>
</li>
<li><p>同时访问方式</p>
</li>
</ol>
<h3 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h3><p>把一个物理实体变为若干个逻辑上的对应物</p>
<ol>
<li><p>时分复用技术</p>
<p>按时间轮流使用</p>
<ol>
<li>虚拟处理机技术</li>
<li>虚拟设备技术</li>
</ol>
</li>
<li><p>空分复用技术</p>
<p>空间分割为不同区域</p>
<ol>
<li>虚拟磁盘技术</li>
<li>虚拟存储器技术</li>
</ol>
</li>
</ol>
<h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>进程是以人们不可预知的速度向前推进，此即进程的异步性。</p>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理器管理功能"><a href="#处理器管理功能" class="headerlink" title="处理器管理功能"></a>处理器管理功能</h3><ol>
<li><p>进程控制：创建，撤销与状态转化</p>
</li>
<li><p>进程同步</p>
<p>进程互斥方式，对于进程访问临界资源</p>
<p>进程同步方式，对于相互合作去完成共同任务的诸线程</p>
</li>
<li><p>进程通信</p>
</li>
<li><p>调度</p>
<p>作业调度与进程调度</p>
</li>
</ol>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ol>
<li><p>内存分配</p>
<p>分配机制应该有：</p>
<ol>
<li>内存分配数据结构</li>
<li>内存分配功能</li>
<li>内存回收功能</li>
</ol>
</li>
<li><p>内存保护，访问控制</p>
</li>
<li><p>地址映射，虚地址到实地址</p>
</li>
<li><p>内存扩充，虚拟存储技术</p>
</li>
</ol>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><ol>
<li><p>缓冲管理</p>
<p>由于CPU的高速与I/O的低速，需要两者间设立缓冲区</p>
</li>
<li><p>设备分配</p>
</li>
<li><p>设备处理，实现CPU和设备控制器之间的通信</p>
</li>
</ol>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ol>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读/写管理和保护</li>
</ol>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ol>
<li>用户接口，例如命令<ol>
<li>联机用户接口</li>
<li>脱机用户接口，联机脱机的区别在于即时通信</li>
<li>图形用户接口</li>
</ol>
</li>
<li>程序结构，例如shell编程</li>
</ol>
<h2 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h2><h3 id="传统的操作系统结构"><a href="#传统的操作系统结构" class="headerlink" title="传统的操作系统结构"></a>传统的操作系统结构</h3><ol>
<li>无结构操作系统</li>
<li>模块化结构OS</li>
<li>分层式结构OS</li>
</ol>
<p>C/S模式</p>
<p>面向对象的程序设计</p>
<h3 id="微内核OS结构"><a href="#微内核OS结构" class="headerlink" title="微内核OS结构"></a>微内核OS结构</h3><ol>
<li><p>基本概念</p>
<ol>
<li><p>足够小的内核：只完成操作系统最基本的部分</p>
</li>
<li><p>基于C/S模式：绝大部分功能为进程提供</p>
</li>
<li><p>机制与策略分离</p>
<p>机制，某一功能的具体执行机构</p>
<p>策略，用算法组织机制，优化功能或实现新功能</p>
</li>
<li><p>采用面向对象技术</p>
</li>
</ol>
</li>
<li><p>基本功能</p>
<ol>
<li>进程管理</li>
<li>低级存储器管理，例如地址映射，页表机制</li>
<li>中断与陷入处理</li>
</ol>
</li>
<li><p>优点</p>
<p>提高了可拓展性，可靠性，可移植性。提供了对分布式系统的支持，融入了面向对象技术</p>
</li>
<li><p>存在的问题：效率不高</p>
</li>
</ol>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><h3 id="程序的顺序执行及其特征"><a href="#程序的顺序执行及其特征" class="headerlink" title="程序的顺序执行及其特征"></a>程序的顺序执行及其特征</h3><p>顺序性，封闭性，可再现性</p>
<h3 id="前驱图-DAG"><a href="#前驱图-DAG" class="headerlink" title="前驱图 DAG"></a>前驱图 DAG</h3><h3 id="程序的并发执行及其他特征"><a href="#程序的并发执行及其他特征" class="headerlink" title="程序的并发执行及其他特征"></a>程序的并发执行及其他特征</h3><ol>
<li><p>程序的并发执行</p>
<p>并发执行可能导致不按照原有顺序执行</p>
</li>
<li><p>程序并发执行时的特征</p>
<ol>
<li>间断性，走走停停</li>
<li>失去封闭性，不再独享资源</li>
<li>不可再现性，不按原有顺序执行</li>
</ol>
</li>
</ol>
<h3 id="进程的特征与状态"><a href="#进程的特征与状态" class="headerlink" title="进程的特征与状态"></a>进程的特征与状态</h3><ol>
<li><p>进程的特征与定义</p>
<p>为使程序能够并发执行，且为了对并发执行的程序加以描述和控制而引入进程</p>
<ol>
<li>结构特点：程序段，数据段和PCB，其中PCB是进程存亡的关键</li>
<li>动态性，进程的实质是进程实体的一次执行过程</li>
<li>并发性</li>
<li>独立性，不建立PCB就无法运行</li>
<li>异步性</li>
</ol>
<p>定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
</li>
<li><p>进程的三种基本状态：就绪，执行和阻塞</p>
</li>
<li><p>挂起状态</p>
</li>
<li><p>创建状态与中止状态</p>
</li>
</ol>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><ol>
<li><p>作用</p>
<p>记录了操作系统所需的，用于描述进程当前情况以及控制进程运行的全部信息，PCB是进程存在的唯一标志。</p>
</li>
<li><p>信息</p>
<ol>
<li>进程标识符</li>
<li>处理机状态，寄存器</li>
<li>进程调度信息，状态，优先级，阻塞原因</li>
</ol>
</li>
<li><p>组织方式</p>
</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>原语是若干条指令组成的用于完成一定功能的具有原子性的一个过程</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol>
<li><p>进程图，描述父子关系，子进程能够继承父进程所拥有的资源</p>
</li>
<li><p>创建进程的事件：用户登录，作业调度，提供服务和应用请求</p>
</li>
<li><p>进程的创建</p>
<p>申请空白PCB-分配资源-初始化PCB-插入进就绪队列</p>
</li>
</ol>
<h3 id="进程的中止"><a href="#进程的中止" class="headerlink" title="进程的中止"></a>进程的中止</h3><ol>
<li><p>引起进程终止的事件：正常结束，异常结束和外界干预</p>
</li>
<li><p>进程的终止过程</p>
<p>读取状态-若正在执行，则终止执行，重新调度-终止子孙进程-归还资源-移除队列</p>
</li>
</ol>
<h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><ol>
<li><p>引起进程阻塞和唤醒的事件：请求系统服务，启动某种操作，新数据尚未到达，无新工作可做</p>
</li>
<li><p>进程阻塞过程</p>
<p>进程主动调用block原语-若处于执行状态则停止执行-改变PCB内状态-插入阻塞队列-转调度程序</p>
</li>
<li><p>进程唤醒过程</p>
<p>有关进程调用唤醒原语wakeup-从阻塞队列中移出-改变PCB内状态为就绪-插入就绪队列</p>
</li>
</ol>
<h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><ol>
<li><p>挂起</p>
<p>自己或父进程请求，系统将利用suspend原语</p>
<p>过程：就绪变为静止就绪，活动阻塞变为静止阻塞</p>
</li>
<li><p>激活</p>
<p>父进程或用户进程请求，系统使用active原语</p>
</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>主要任务：对多个相关进程在执行次序上进行协调，以便并发执行的诸进程之间能够有效地共享资源和相互合作从而使程序的执行具有可再现性</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>两种形式的制约关系</p>
<p>间接相互制约关系：共享某种系统资源</p>
<p>直接相互制约关系：源于进程间合作</p>
</li>
<li><p>临界资源</p>
</li>
<li><p>临界区</p>
<p>每个进程种访问临界资源的那段代码</p>
</li>
<li><p>同步机制应遵循的规则</p>
<p>空闲让进，忙则等待，有限等待，让权等待（不能进入临界区时，立即释放处理机）</p>
</li>
</ol>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ol>
<li><p>整型信号量，wait(S)，signal(S)两个原子操作也成为PV操作</p>
</li>
<li><p>记录型信号量，多个进程等待同一临界资源，需要一个进程链表指针</p>
</li>
<li><p>AND型信号量，访问多个临界资源，防止发生死锁，必须同时申请所有资源</p>
</li>
<li><p>信号量集，多种资源，且每种资源可能有多个</p>
<p>Swait(S,d1,d1)每次申请d1个S资源，当S资源小于d2个不予分配</p>
</li>
</ol>
<h3 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h3><ol>
<li>利用信号量实现进程互斥（基本功能）</li>
<li>利用信号量实现前趋关系（利用signal()释放初始量小于1的信号量）</li>
</ol>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><ol>
<li><p>定义</p>
<p>Hansan:一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<p>特点：模块化，抽象数据类型和信息隐藏</p>
<p>和进程的不同：</p>
<ol>
<li>管程为公共数据结构</li>
<li>用于同</li>
<li>为了解决共享资源的互斥</li>
<li>被动工作</li>
<li>管程不能与其调用者并发</li>
<li>资源管理模块，没有明显的生存周期</li>
</ol>
</li>
<li><p>条件变量</p>
<p>基本与信号量相同。</p>
<p>当P唤醒Q时：<br>P紧急等待，Q继续，直到Q退出或等待；(Hoare)</p>
<pre><code>Signal and urgent wait
</code></pre><p>Q等待，P继续，直到P退出或等待；(Java)</p>
<pre><code>Signal and continue
被唤醒进程需要重新检查等待条件,可能再次等待.
</code></pre><p>唤醒是管程中可执行的最后一个操作。(Hansen)</p>
<pre><code>Signal and leave
</code></pre></li>
</ol>
<h2 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h2><p>注：一般来说先同步再互斥</p>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ol>
<li><p>记录型信号量</p>
<p>mutex用于管理缓冲池互斥，empty用于空队列的同步，full用于满队列的同步</p>
</li>
<li><p>AND信号量</p>
<p>与上文相同，用Swait(empty,mutex)等替代原有操作</p>
</li>
<li><p>管程</p>
<p>定义整个缓冲池，信号量与放置，取走与初始化操作，</p>
</li>
</ol>
<h3 id="哲学家用餐问题"><a href="#哲学家用餐问题" class="headerlink" title="哲学家用餐问题"></a>哲学家用餐问题</h3><ol>
<li><p>记录型信号量</p>
<p>可能存在死锁</p>
</li>
<li><p>AND信号量</p>
<p>一次申请两只筷子</p>
</li>
<li><p>管程</p>
</li>
</ol>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ol>
<li><p>记录型信号量</p>
<p>Wmute用于读写互斥，当ReadCount=0时，读者才需要Wait(Wmutex)，ReadCount=1时才需要Signal(Wmutex)。</p>
<p>Rmutex用于对ReadCount的互斥。</p>
</li>
<li><p>信号量集</p>
<p>此时问题增加约束，最多同时容纳Rn个读者，</p>
<p>L用于同步剩余读者容量</p>
<p>mx用于读写互斥</p>
</li>
</ol>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>信号量机制的缺点：</p>
<ol>
<li>效率低，每次只能对一个数据操作</li>
<li>通信对用户不透明，需要用户参与设计数据结构</li>
</ol>
<h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol>
<li><p>共享存储器系统</p>
<p>共享数据结构或共享存储区进行通信。</p>
<ol>
<li>共享数据结构，需要程序员设计数据结构，增加了程序员负担</li>
<li>共享存储区</li>
</ol>
</li>
<li><p>信号传递系统</p>
<p>以格式化的消息(message)为单位传输，微内核中常用，可分为直接通信与间接通信方式</p>
</li>
<li><p>管道通信</p>
<p>管道：连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。</p>
<p>需要互斥，同步和确定对方存在三个功能。</p>
</li>
</ol>
<h3 id="消息传递通信的实现"><a href="#消息传递通信的实现" class="headerlink" title="消息传递通信的实现"></a>消息传递通信的实现</h3><ol>
<li><p>直接通信方式</p>
<p>直接通过Send(Receiver,message)和Receive(Sender,message)收发消息</p>
</li>
<li><p>间接通信方式</p>
<p>用信箱作为共享数据结构的实体，用于存放消息。</p>
<ol>
<li>私有信箱：自己rw,其他w</li>
<li>公有信箱：操作系统创建，核准进程使用，系统运行期间都存在</li>
<li>共享信箱：某进程创建，可授权给别的的进程。</li>
</ol>
</li>
</ol>
<h3 id="消息传递系统实现的若干问题"><a href="#消息传递系统实现的若干问题" class="headerlink" title="消息传递系统实现的若干问题"></a>消息传递系统实现的若干问题</h3><ol>
<li><p>通信链路</p>
<p>面对连接和面对无链接</p>
</li>
<li><p>消息的格式</p>
<p>定长or变长，有无消息头</p>
</li>
<li><p>进程同步方式</p>
<ol>
<li><p>发送进程阻塞，接收进程阻塞</p>
<p>也称为汇合，用于紧密同步</p>
</li>
<li><p>发送进程不阻塞，接收进程阻塞</p>
<p>应用最广，发送进程不阻塞以实现快速将多个消息发给多个目标</p>
</li>
<li><p>发送进程接收进程都不阻塞</p>
<p>较常见，由于消息队列的存在，只要消息队列非空或非满就不阻塞</p>
</li>
</ol>
</li>
</ol>
<h3 id="消息缓冲队列通信机制"><a href="#消息缓冲队列通信机制" class="headerlink" title="消息缓冲队列通信机制"></a>消息缓冲队列通信机制</h3><ol>
<li><p>消息缓冲队列通信机制中的数据结构</p>
<p>消息缓冲区：链表实现</p>
<p>PCB有关通信的数据项：要存储消息队列的互斥信号量与资源信号量</p>
</li>
<li><p>发送原语</p>
<p>按照消息大小申请缓冲区，复制入发送去-获取接收进程PID-插入缓冲区（互斥）</p>
</li>
<li><p>接受原语</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><ol>
<li><p>线程的引入</p>
<p>进程：可拥有资源的独立单位，同时是可独立调度和分配的基本单位。由于拥有资源，进程的创建、撤销和切换代价过大。故而让进程成为资源分配的单位，线程作为调度的单位</p>
</li>
<li><p>线程和进程的比较</p>
<p>在引入了线程的操作系统中，通常一个进程都拥有若干个线程、</p>
<ol>
<li><p>调度</p>
<p>在同一进程中，线程的切换不会导致进程的切换，但不同的进程的线程切换时，会导致进程的切换</p>
</li>
<li><p>并发性</p>
<p>一个进程有多个线程并发，减少了进程被阻塞的几率，提高了系统吞吐量</p>
</li>
<li><p>拥有资源</p>
<p>一般而言，线程自己不拥有系统资源</p>
</li>
<li><p>系统开销</p>
<p>由于不拥有资源（拥有资源少），保存的现场信息少，系统开销小</p>
</li>
</ol>
</li>
<li><p>线程的属性</p>
<ol>
<li>轻型实体</li>
<li>独立调度和分派的基本单位</li>
<li>可并发执行</li>
<li>共享进程资源</li>
</ol>
</li>
<li><p>线程的状态</p>
<ol>
<li>状态参数：寄存器状态，堆栈，线程运行状态，优先级，线程专用存储器，信号屏蔽</li>
<li>线程运行状态：执行-就绪-阻塞</li>
</ol>
</li>
<li><p>线程的创建和终止</p>
<p>创建：存在初始线程</p>
<p>终止： 自愿退出，错误或被其他进程终止。终止后并不立即释放所占有的资源，而在其他线程执行分离函数后才与资源分离</p>
</li>
<li><p>多线程OS中的进程</p>
<p>作为资源分配的单位，可包括多个进程（最少一个），不再是一个可执行的实体</p>
</li>
</ol>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><ol>
<li><p>互斥锁</p>
</li>
<li><p>条件变量</p>
<p>互斥锁用于互斥进入数据段，条件变量用于线程的长期等待。进入不等同于占有，减少死锁可能性</p>
</li>
<li><p>信号量机制</p>
<p>公有信号量：OS创建</p>
<p>私有信号量：进程创建，进程被撤销时无法通知所有进程，故而存在风险</p>
</li>
</ol>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ol>
<li><p>内核支持线程</p>
<p>线程操作都在内核空间内实现，内核空间存在线程控制块，内核知道线程的存在</p>
<p>优点：</p>
<ol>
<li>内核能同时调度一个进程中的多个线程并行执行</li>
<li>若进程中的一个线程被阻塞可以调度进程内的另一个线程</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程切换快，开销小</li>
<li>内核本身也可多线程实现，提高系统的执行速度和效率</li>
</ol>
<p>缺点：线程切换时需要从用户态转到内核态，系统开销大</p>
</li>
<li><p>用户级线程</p>
<p>线程操作与内核无关，内核完全不知道用户级线程的存在，调度仍以进程为单位，故而进程线程越多，每个线程被分配的进程时间越少。</p>
<p>优点：</p>
<ol>
<li>进程切换不需要转换到内核空间</li>
<li>调度算法可以是进程专有的</li>
<li>实现与操作系统无关</li>
</ol>
<p>缺点：</p>
<ol>
<li>线程被阻塞时整个进程都会被阻塞</li>
<li>由于进程每次只被分配到一个处理机，故而同一时刻进程内只有一个线程在运行</li>
</ol>
</li>
<li><p>组合方式</p>
</li>
</ol>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ol>
<li><p>内核支持线程的实现</p>
<p>内核空间创建任务数据区PTDA，其中存储TCB。（进程变为了管理进程资源的PTDA）</p>
</li>
<li><p>用户级线程的实现</p>
<ol>
<li><p>运行时系统</p>
<p>相当于一个放置于用户态的线程控制系统，是管理和控制线程的函数的集合，因此线程的切换不再需要进入内核。</p>
</li>
<li><p>内核控制线程</p>
<p>上文提及用户级线程一个进程内的线程因为系统调用整个进程都将被阻塞，为了解决这个矛盾，内核提供了多个接口用于为进程中的线程提供服务，此接口被称为轻型进程LWP。当线程需要访问内核空间时将自身装载进LWP，进入内核空间后变为内核级线程。而原进程将不被阻塞。</p>
</li>
</ol>
</li>
<li><p>用户级线程和内核控制线程的连接</p>
<p>一对一，多对一，多对多</p>
</li>
</ol>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><ol>
<li>作业调度（高级调度）</li>
<li>存储器调度（中级调度）</li>
<li>进程调度（低级调度）</li>
</ol>
<p>频率：低级调度&gt;中级调度&gt;高级调度。越高频调度算法就应该越简单</p>
<h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><ol>
<li><p>作业与作业步</p>
<ol>
<li>作业：程序，数据和作业说明书</li>
<li>作业步：每个作业都需要经过若干个相对独立又相互关联的顺序加工步骤才能得到结果，其中每一个加工步骤称为一个作业步。编译作业步-连结装配作业步-运行作业步</li>
<li>作业流：有次序地存放若干个位于外存的作业的队列</li>
</ol>
</li>
<li><p>作业控制快</p>
<p>包含标识，用户信息，作业类型，作业状态，调度信息，资源需求等信息</p>
<p>进入系统时，系统为每个作业建立一个JCB，根据作业类型分配在不同的后备队列，由作业调度程序调度，被调度到的作业将被进入内存</p>
</li>
<li><p>作业调度</p>
<p>用户希望自己作业平均周转时间尽可能少，系统希望平均周转时间尽可能少</p>
<p>需要考虑：决定接纳多少个作业，决定接纳哪些作业</p>
</li>
</ol>
<h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><ol>
<li>低级调度的功能<ol>
<li>保存处理机的进程信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ol>
</li>
<li>进程调度中的三个基本机制<ol>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换机制</li>
</ol>
</li>
<li>进度调度方式<ol>
<li>非抢占方式：当前进程在自愿退出后阻塞后才归还处理机</li>
<li>抢占方式：调度程序暂停某个正在执行的进程，将它的处理机重新分配，原则：优先权原则，短作业优先原则，时间片原则</li>
</ol>
</li>
</ol>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>为了节省内存，将暂时用不到的进程挂起，即调至外存等待。</p>
<h2 id="调度队列模型对调度准则"><a href="#调度队列模型对调度准则" class="headerlink" title="调度队列模型对调度准则"></a>调度队列模型对调度准则</h2><h3 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h3><ol>
<li>仅有进程调度的调度队列模型</li>
<li>具有高级和低级调度的调度队列模型</li>
<li>同时具备三级调度的调度队列模型</li>
</ol>
<h3 id="选择调度方式和调度算法的若干准则"><a href="#选择调度方式和调度算法的若干准则" class="headerlink" title="选择调度方式和调度算法的若干准则"></a>选择调度方式和调度算法的若干准则</h3><ol>
<li><p>面向用户的准则</p>
<ol>
<li><p>周转时间短</p>
<p>周转时间：作业提交到系统到作业完成为止的时间间隔</p>
<p>带权周转时间：作业周转时间和系统为它提供服务的时间之比</p>
</li>
<li><p>响应时间快，提交到初次相应的时间</p>
</li>
<li><p>截止时间保证</p>
</li>
<li><p>优先权原则</p>
</li>
</ol>
</li>
<li><p>面向系统的准则</p>
<ol>
<li>系统吞吐量高</li>
<li>处理机利用率好</li>
<li>各类资源平衡利用</li>
</ol>
</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>调度的实质是一种资源分配</p>
<h3 id="先来先服务和短作业优先调度算法"><a href="#先来先服务和短作业优先调度算法" class="headerlink" title="先来先服务和短作业优先调度算法"></a>先来先服务和短作业优先调度算法</h3><ol>
<li>先来先服务调度算法，有利于长作业</li>
<li>短作业优先调度算法，有利于短作业，长作业可能被饿死</li>
</ol>
<h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><ol>
<li><p>优先权调度算法的类型：非抢占式和抢占式</p>
</li>
<li><p>优先权的类型</p>
<p>静态优先权：创建进程时确定，运行时不变</p>
<ol>
<li>进程类型，系统进程&gt;用户进程</li>
<li>进程对资源的需求，占有资源少优先</li>
<li>用户要求</li>
</ol>
<p>动态优先权：可变的</p>
</li>
<li><p>高响应比优先调度算法</p>
<script type="math/tex; mode=display">
R_p = \frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}</script></li>
</ol>
<p>可以体现：</p>
<ol>
<li>短作业优先</li>
<li>等待时间越长，优先权越高，即先来先服务</li>
<li>对于长作业，等待时间越长优先级也会越高</li>
</ol>
<h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><ol>
<li>时间片轮转法<ol>
<li>基本原理：先按先来先服务的原则排成一个队列，获得一次时间片后将进程移动至队列尾部</li>
<li>时间片大小的确定：过短增加系统开销，过长无法满足交互式用户的需求，可取的大小是也略大于一次典型的交互所需要的时间</li>
</ol>
</li>
<li>多级反馈队列调度算法<ol>
<li>多个队列，越靠后的队列优先级越低但获得的时间片越长</li>
<li>新进程先进入第一个队列的尾部，获得时间片后移动至下一个队列</li>
<li>只有优先权高的队列为空时才运行优先权低的队列中的进程</li>
</ol>
</li>
<li>多级反馈队列调度算法的性能<ol>
<li>终端型作业用户，若在第一个队列完成则可满意</li>
<li>短批处理作业用户，周转时间短</li>
<li>长批作业处理用户，不会被饿死</li>
</ol>
</li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol>
<li><p>提供必要的信息</p>
<p>就绪时间，开始截止时间和完成截止时间，处理时间，资源要求，优先级</p>
</li>
<li><p>系统处理能力强</p>
<script type="math/tex; mode=display">
假设系统中由m个周期性的硬实时任务，他们的处理时间可以表示为C_i，周期时间表示为P_i，处理机数量N\\
\sum_{i=1}^{m}\frac{C_i}{P_i}\le N</script></li>
<li><p>采用抢占式调度机制</p>
</li>
<li><p>具有快速切换机制：对外部中断的快速响应能力。快速的任务分派能力</p>
</li>
</ol>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><ol>
<li>非抢占式调度算法：非抢占式轮转调度算法，非抢占式优先调度算法</li>
<li>抢占式调度算法<ol>
<li>基于时钟中断的抢占式优先权调度算法，时钟中断到来时，调度算法才剥夺当前任务的执行</li>
<li>立即抢占的优先权调度算法</li>
</ol>
</li>
</ol>
<h3 id="常用的几种实时调度算法"><a href="#常用的几种实时调度算法" class="headerlink" title="常用的几种实时调度算法"></a>常用的几种实时调度算法</h3><ol>
<li><p>最早截至时间有限即EDF算法</p>
<p>根据任务的开始截止时间来确定任务的优先级，越早优先权越高</p>
<p>可抢占也可非抢占，抢占式灵活度更高更不容易错过任务。</p>
</li>
<li><p>最低松弛度优先即LLF算法</p>
<p>松弛度=剩余时间-运行时间，一般都为抢占式</p>
</li>
</ol>
<h2 id="产生死锁的原因与必要条件"><a href="#产生死锁的原因与必要条件" class="headerlink" title="产生死锁的原因与必要条件"></a>产生死锁的原因与必要条件</h2><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>竞争资源引起的进程死锁<ol>
<li>可剥夺与非剥夺性资源，区别能否强行收回，前者例如内存区，后者比如打印机</li>
<li>竞争非剥夺性资源可能造成死锁</li>
<li>竞争临时性资源，比如消息，进程通信可能造成死锁</li>
</ol>
</li>
<li>进程推进顺序不当引起死锁</li>
</ol>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ol>
<li>互斥条件，即在一段时间内内某资源只由一个进程占用</li>
<li>请求和保持条件，进程保持了至少一个资源，但又提出了新的资源请求</li>
<li>不剥夺条件，资源在未使用完之前不能被剥夺</li>
<li>环路等待条件，存在一个进程-资源的环形链</li>
</ol>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><ol>
<li>预防死锁，打破死锁的必要条件，一般条件过于严格，会降低系统吞吐量</li>
<li>避免死锁，防止系统进入不安全状态，条件较弱</li>
<li>检测死锁</li>
<li>接触死锁，撤销或挂起一些进程</li>
</ol>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>互斥条件是设备属性无法避免</p>
<ol>
<li><p>摒弃“请求和保持”条件</p>
<p>进程必须一次性申请所有资源，简单易于实现且很安全，但资源由于可能存在闲置而被严重浪费</p>
</li>
<li><p>摒弃“不剥夺”条件</p>
<p>当一个保持了某些资源的进程再提出新的资源请求而不能立即得到满足时，必须释放他已经保持了的所有资源。被迫释放可能会造成前段工作的失效</p>
</li>
<li><p>摒弃“环路等待条件”</p>
<p>为所有资源按类型进程线性排队，并赋予不同的需要，必须严格按照资源需要递增的顺序提出请求。</p>
<p>限制了新类型设备的增加，请求顺序和使用顺序的不同可能造成资源浪费，对用户编程提出了限制</p>
</li>
</ol>
<h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ol>
<li><p>安全状态</p>
<p>系统能按照某种进程顺序，来为每个进程分配其所需的资源直至满足每个进程对资源的最大需求，使每个进程都可顺利完成</p>
</li>
<li><p>由安全状态向不安全状态的转换</p>
<p>如果不按照安全序列分配资源，就有进入不安全状态的可能性</p>
</li>
</ol>
<h3 id="利用银行家算法避免死锁"><a href="#利用银行家算法避免死锁" class="headerlink" title="利用银行家算法避免死锁"></a>利用银行家算法避免死锁</h3><ol>
<li><p>数据结构</p>
<p>需要记录</p>
<ol>
<li>可利用资源向量Available，记录每类资源可用的数量</li>
<li>最大需求矩阵Max，记录每个进程对每类资源的最大需求量</li>
<li>分配矩阵Allocation，记录每个进程占有的每类资源的数量</li>
<li>需求矩阵Need，记录每个进程对每类资源的需求量</li>
</ol>
</li>
<li><p>银行家算法</p>
<p>对于每次申请考虑以下问题</p>
<ol>
<li>需求是否合法$Request_i[j]\le Need[i,j]$，不合法则出错</li>
<li>需求是否可满足$Request_i[j]\le Available[j]$，不满足则等待</li>
<li>试探分配</li>
<li>执行安全性算法，若结果安全才真的分配，若不安全则不完成此次分配，进程等待</li>
</ol>
</li>
<li><p>安全性算法</p>
<p>遍历所有进程，查看是否当前可用资源是否可满足某进程所需的剩余资源，若可满足，则收回该进程持有的所有资源并标记为完成。如果存在进程序列可让所有进程完成，则该分配安全</p>
</li>
</ol>
<h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>系统需要保存有关资源的请求与分配信息与检测死锁的有效算法</p>
<ol>
<li>资源分配图，资源指向进程指进程占用资源，进程指向资源指进程请求资源</li>
<li>死锁定理，与安全性算法相似，若可以满足进程的所有需求，则释放进程所占有的资源</li>
<li>死锁检测中的数据结构，与银行家算法类似</li>
</ol>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><ol>
<li>剥夺资源</li>
<li>撤销进程</li>
</ol>
<p>而这两种方法代价都很大，故而我们可以先预处理出所有进程的撤销代价，每次选取代价最小的进程撤销</p>
<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>脉络：</p>
<ol>
<li>程序需要全部装入内存，固定分区和动态分区，基本分页分段</li>
<li>对换技术</li>
<li>程序只需要部分装入内存，请求分页分段</li>
</ol>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多级存储器结构"><a href="#多级存储器结构" class="headerlink" title="多级存储器结构"></a>多级存储器结构</h3><p>寄存器-主存-辅存</p>
<p>可细分为</p>
<p>寄存器-（高速缓存-主存-磁盘缓存）-（磁盘-可移动存储介质）</p>
<h3 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h3><ol>
<li><p>主存储器</p>
<p>访问速度远低于CPU执行速率，CPU只能冲主存储器中获得指令与数据。</p>
</li>
<li><p>寄存器</p>
<p>访问最快，能与CPU协调工作，但价格十分昂贵</p>
</li>
</ol>
<h3 id="高速缓存与磁盘缓存"><a href="#高速缓存与磁盘缓存" class="headerlink" title="高速缓存与磁盘缓存"></a>高速缓存与磁盘缓存</h3><ol>
<li><p>高速缓存</p>
<p>局部性原理，存储部分主存内容，比主存访问速度快</p>
</li>
<li><p>磁盘缓存</p>
<p>主存上的一个空间，用于暂存磁盘中读出和写入的数据</p>
</li>
</ol>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>编译-链接-装入模块-装入程序</p>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><ol>
<li><p>绝对装入方式</p>
<p>编译程序产生绝对地址的目标代码</p>
</li>
<li><p>可重定位装入方式</p>
<p>装入时一次完成的，目标地址为装入地址和相对偏移的组合</p>
</li>
<li><p>动态运行时装入方式</p>
<p>地址转换在真正执行时才进行，用于适配虚拟存储器机制</p>
</li>
</ol>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ol>
<li><p>静态链接</p>
<p>链接时完成，以后不再分开</p>
</li>
<li><p>装入时动态链接</p>
<p>边装入边链接</p>
</li>
<li><p>运行时动态链接</p>
<p>真正用到时再装入</p>
</li>
</ol>
<h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>用于单用户单任务的从操作系统中，只分为系统区与用户区，用户区全部交给用户</p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ol>
<li><p>划分分区的方式</p>
<ol>
<li>分区大小相等，缺乏灵活性，会造成浪费</li>
<li>分区大小不等</li>
</ol>
</li>
<li><p>内存分配</p>
<p>按分区大小进行排序，并建立一个分区使用表标记分配情况</p>
</li>
</ol>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol>
<li><p>分区分配中的数据结构</p>
<p>空闲分区表与空闲分区链</p>
</li>
<li><p>分区分配算法</p>
<ol>
<li>首次适应算法，分配一个大小足够的空闲分区，高地址保留了大空闲区，低址会留下碎片 </li>
<li>循环首次适应算法，从上次找到的空闲分区的下一个空闲分区开始查找，空闲分区更均匀，但缺少大空闲区</li>
<li>最佳适应算法，分配满足需求的最小空闲分区，碎片过小导致无法使用</li>
<li>最坏适应算法，分配满足需求的最大空闲分区，产生碎片概率小</li>
<li>快速适应算法，分类搜索，将空闲分区按照不同大小分为多个链便于检索</li>
</ol>
</li>
<li><p>分区分配操作</p>
<ol>
<li>分配内存，检索与分割</li>
<li>回收内存，相邻则合并</li>
</ol>
</li>
</ol>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>将空闲分区初始设置为$2^m$个字的空闲区，为进程分配一个长度为n的空间时，令$2^{k-1}\lt n \le2^k$ 寻找长度为$2^k$的空闲分区，若没有则寻找$2^{k+1}$，若仍然没有则寻找$2^{k+2}$，以此类推，直到找到最小的$2^j$长的空闲分区，将$2^k$分配给进程，剩余$2^{j-k}$放入对应链表。回收时，若回收将其放入$2^k$长度对应链表中，若已存在一个$2^k$的空闲区，则合并为$2^{k+1}$长的空闲分区，以此类推</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>建立以空间大小为关键字的哈希表用于检索。</p>
<h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><ol>
<li><p>动态重定位的引入</p>
<p>当内存空间进行一次紧凑后，程序所在的物理地址发生了变化，为使程序不丢失，以逻辑地址代替物理地址，即重定位</p>
</li>
<li><p>动态重定位的实现</p>
<p>用重定位寄存器存放一个基址，并以此计算出物理地址</p>
</li>
<li><p>动态重定位分区分配算法</p>
<p>与非动态的区别在于紧凑时需要修改有关的数据结构</p>
</li>
</ol>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><ol>
<li><p>对换的引入</p>
<p>将暂时用不到的进程或程序和数据调到外存以腾出内存空间。如果对换是以进程为单位，则称之为进程对换，如果是以页或段为单位，则称部分对换。</p>
</li>
<li><p>对换空间的管理</p>
<p>连续分配，分配与回收与动态分区方式相同。</p>
</li>
<li><p>进程的换出与换入</p>
<ol>
<li>换出，无足够内存时考虑，优先选择处于阻塞状态且优先级最低的进程移植外存，回收内存并修改PCB。</li>
<li>换入，系统定时检查所有进程状态，找出就绪但已被换出的进程，将其中换出时间最久的进程换入，直至没有可换出的进程</li>
</ol>
</li>
</ol>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><p>将一个进程直接分散地装入到许多不相邻接的分区中。</p>
<h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><ol>
<li>页面<ol>
<li>将一个进程的逻辑地址空间分为若干个大小相等的片称为页面或页，把内存空间分成与页面大小相等的若干个存储块称为物理块或页框，页面大小由系统决定。</li>
<li>页面太小，虽然碎片少但页表过长占用内存，页面太大，提高换入换出效率，但碎片大</li>
</ol>
</li>
<li>地址结构，页号+位移量</li>
<li>页表，属于进程，一张用于将页号映射到物理块号的页面映像表</li>
</ol>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>用于将逻辑地址转换为物理地址</p>
<ol>
<li><p>基本的地址变换机构</p>
<p>系统中只设置一个页表寄存器PTR，用于存放页表在内存的基址与页表的长度，而对应的数据存储于PCB中，进程被调度时才将对应数据装入PTR。</p>
<p>检查越界-页号变换-与位移量结合为物理地址</p>
</li>
<li><p>具有快表的地址变换机构</p>
<p>CPU没存取一个数据要访问两次内存（页表，数据），为了提升地址变换速度，增设了快表(TLB)，作为页表的一个高速缓冲寄存器，只有在快表中没找到数据才查找页表，并从快表中淘汰一个数据用于存放新数据。局部性原理，快表中查到的概率大概为90% </p>
</li>
</ol>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>分页过多时，页表项数过多导致占用内存大，而且要求存储空间是连续的。</p>
<p>解决方法：</p>
<p>采用离散分配的方式，或只存放部分页表项到内存</p>
<ol>
<li><p>两级页表</p>
<p>逻辑地址：外部页号，外部页内地址，页内地址。外部页号指向一个作为页表的物理块，减少搜索时间</p>
</li>
<li><p>多级页表</p>
<p>32位两级，64位三级</p>
<p>考虑存在多级页表其中页表项数分别为$2^i,2^j,2^k$，要求总页表数最少则考虑$min\{1+2^i+2^{i+j},1+2^i+2^{i+k},1+2^j+2^{k+j},\dots\}$，即一级页表一个，二级页表数量为一级页表页表项数，三级页表为一级页表和二级页表的页表项数的乘积，以此类推。</p>
</li>
</ol>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><p>目的：</p>
<ol>
<li>方便编程，将信息按照逻辑关系分离</li>
<li>信息共享，段是逻辑单位，可让程序员将其作为分享的单位</li>
<li>信息保护，信息为单位进行保护</li>
<li>动态增长，适合不断增大的程序、而不需要划分新的单位</li>
<li>动态链接，可以段为单位装入程序，实现动态链接</li>
</ol>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ol>
<li><p>分段</p>
<p>逻辑地址分为段号和段内地址，由于段内地址长度固定，段存在最大长度</p>
</li>
<li><p>段表</p>
<p>段表中的需要存储每个段的长度与基址</p>
</li>
<li><p>地址变换机构</p>
<p>检查段号是否越界-获取段长与基址-检查段内偏移是否越界-生成物理地址</p>
</li>
<li><p>分页和分段的主要区别</p>
<ol>
<li>页是物理单位，为了实现离散分配而存在，为系统服务。段是逻辑单位，含有一组有实际意义的信息，<strong>为程序员服务</strong></li>
<li>页大小固定，段大小<strong>可变</strong></li>
<li>分页是一维的，程序员只需要知道逻辑地址，而分段是二维的，程序员需要知道是哪个段以及段内地址</li>
</ol>
</li>
</ol>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>将数据段和程序段分离，当程序被多个用户使用时，只需要给每个用户分配不同的数据段与一个程序段就可为多个用户服务</p>
<p>可重入代码又称为纯代码，是一种运行中不会被改变的代码，只需要把局部数据的存储区与它分离就可做到</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol>
<li><p>基本原理</p>
<p>每个段分为若干个页（分配的单位变为了页而非字节），逻辑地址=段号+段内页号+页内地址</p>
</li>
<li><p>地址变换过程</p>
<p>段号是否越界-取得段的页表-页号是否越界-组合物理地址</p>
</li>
</ol>
<h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><p>两种可能出现的问题</p>
<ol>
<li>作业过大无法全部装入内存</li>
<li>每次只能装入少量的作业，吞吐量下降</li>
</ol>
<h3 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h3><ol>
<li><p>常规存储器管理方式的特征</p>
<p>一次性：要求把作业一次性地把全部内容装入内存</p>
<p>驻留性：装入内存后，在运行结束前都需要一直驻留在内存中</p>
</li>
<li><p>局部性原理</p>
<p>几个论点：</p>
<ol>
<li>除了少数转移指令和过程调用指令，大部分是<strong>顺序执行</strong></li>
<li>过程调用的深度一般不超过5</li>
<li>循环结构会使少数代码被反复运行</li>
<li>对数据结构的处理，使得操作被局限在很小的范围内</li>
</ol>
<p>两个方面：</p>
<ol>
<li>时间局限性，被运行到的指令在一段时间后可能被再次运行</li>
<li>空间局限性，被访问的数据单元附近的数据单元可能也会被访问</li>
</ol>
</li>
<li><p>虚拟存储器的定义</p>
<p>由于局部性原理，无需将整个程序装入内存，只需要装入部分数据。当所需数据不在内存上而内存已满时需要置换页面。</p>
<p>虚拟存储器：具有请求调入功能和置换功能，能从<strong>逻辑上</strong>对内存空间加以<strong>扩充</strong>的一种存储器系统</p>
</li>
</ol>
<h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>需要实现局部调入的功能，依赖于离散分配的存储管理方式</p>
<ol>
<li><p>分页请求系统</p>
<ol>
<li><p>硬件支持</p>
<p>请求分页的页表机构，页表需要增加若干标识</p>
<p>缺页中断机构，当发现所需页不在内存中，需要中断调入页面</p>
<p>地址变换结构，将逻辑地址变为内存或外存的物理地址</p>
</li>
<li><p>实现请求分页的软件</p>
<p>实现页面置换和页面调入</p>
</li>
</ol>
</li>
<li><p>请求分段系统</p>
<ol>
<li>请求分段的段表机制</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ol>
</li>
</ol>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ol>
<li>多次性，一个作业被分为多次调入内存</li>
<li>对换性，允许将暂不使用的程序和数据，从内存调至外存的对换区</li>
<li>虚拟性，逻辑上扩充内存容量，以前两者为基础</li>
</ol>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><ol>
<li><p>页表机制</p>
<p>页号，物理块号，状态位P，访问字段A，修改位M，外存地址</p>
<p>状态位P：是否调入内存</p>
<p>访问字段A：记录一段时间内被访问的次数</p>
<p>外存地址：外存副本的位置</p>
</li>
<li><p>缺页中断机构</p>
<p>指令执行完后检查是否有中断信号，有可能一条指令造成多次中断，要有保存多次中断的能力</p>
</li>
<li><p>地址变换机构</p>
<p>页号&gt;页表长度？若是产生越界中断</p>
<p>页表项在快表中？若是直接获取数据</p>
<p>页在内存中？若是获取数据，若不是缺页中断</p>
<p>缺页中断：</p>
<p>内存是否满？是则选择一页换出</p>
<p>换出页是否被修改？若是则需写回</p>
</li>
</ol>
<h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol>
<li><p>最小物理块数的确定，程序能运行的最小物理块数</p>
</li>
<li><p>物理块的分配策略</p>
<ol>
<li>固定分配局部置换，给予进程固定数量的物理块，让程序在这些内存物理块上运行</li>
<li>可变分配全局置换，缺页中断时询问系统剩余的物理块</li>
<li>可变分配局部置换，缺页中断时访问程序被分配的剩余物理块，若频繁缺页中断则增加分配的物理块</li>
</ol>
</li>
<li><p>物理块分配算法</p>
<ol>
<li><p>平均分配算法</p>
<p>$物理块/程序数$</p>
</li>
<li><p>按比例分配算法</p>
<p>$b_i=\frac{S_i}{\sum_{i=1}^nS_i}m，S_i：程序所需页面数$</p>
</li>
<li><p>考虑优先权的分配算法</p>
<p>物理块分为两部分，一部分按比例分配，另一部分则适量增加优先权高的进程</p>
</li>
</ol>
</li>
</ol>
<h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><ol>
<li><p>调入页面的时机</p>
<ol>
<li>预调页策略，一次调入若干个相邻的页，多用于进程的首次调入</li>
<li>请求调页策略，一次调一页，造成较大的物理开销</li>
</ol>
</li>
<li><p>确定从何处调入页面</p>
<p>外存分为文件区和对换区，对换区是连续空间而文件区是离散空间</p>
<ol>
<li>系统拥有足够的对换区空间，全部从对换区调入</li>
<li>系统缺少足够的对换区空间，不会被修改的文件从文件区调入，可能被修改的部分从对换区调入，例如程序段和数据段</li>
<li>UNIX方式，未运行的页面都从文件区调入，被换出的页面从对换区调入</li>
</ol>
</li>
<li><p>页面调入过程</p>
<p>对用户透明</p>
<p>保存CPU环境-分析原因-转入缺页中断处理程序-如果内存满则换出一页-换出页若被修改则需重新写入-调入页-修改状态位</p>
</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法和先进先出置换算法"><a href="#最佳置换算法和先进先出置换算法" class="headerlink" title="最佳置换算法和先进先出置换算法"></a>最佳置换算法和先进先出置换算法</h3><ol>
<li>最佳置换算法，将未来最晚被用到页面换出，实际不可行</li>
<li>先进先出置换算法，最早调入的页面被换出</li>
</ol>
<h3 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h3><ol>
<li><p>描述</p>
<p>用最近的过去作为最近的将来的近似，选择最近最久未使用的页面予以淘汰</p>
</li>
<li><p>硬件支持</p>
<ol>
<li>寄存器，每个物理块对应一个寄存器，页面被使用时寄存器最高位置为1，每隔一段时间将所有寄存器中的数右移一位，每次淘汰寄存器中最小的淘汰。</li>
<li>栈，每使用一个页面将其页号移动至栈顶，每次淘汰栈底元素</li>
</ol>
</li>
</ol>
<h3 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h3><p>LRU需求较多硬件需求，Clock作为LRU的近似算法</p>
<ol>
<li><p>简单的clock置换算法</p>
<p>所有页面链接成循环队列，某页被访问则其访问位置1，选择一页访问位为0的换出，访问若为1，则置为0且不将其换出。此算法也叫最近未用算法(NRU)</p>
</li>
<li><p>改进型clock置换算法</p>
<p>每个页面都有访问位A和修改位M</p>
<ol>
<li>扫描一遍寻找A=0,M=0，此次扫描不改变访问位</li>
<li>寻找A=0,M=1作为淘汰页，将所有扫描过的页面的访问位置0</li>
<li>重复第二步</li>
</ol>
<p>减少磁盘I/O，增加了缺页的开销</p>
</li>
</ol>
<h3 id="其他置换算法"><a href="#其他置换算法" class="headerlink" title="其他置换算法"></a>其他置换算法</h3><ol>
<li><p>最少使用LFU</p>
</li>
<li><p>页面缓冲算法</p>
<p>采用FIFO，被淘汰的页放入两个链表，如果未被修改放入空闲链表，否则放入已修改页面的链表。取空闲链表的队首作为空闲物理块装入新读入的页面。淘汰页面时，将页面换出到空闲链表，给予暂留内存，二次淘汰的机会。被修改页面当数量达到一定数额后一起写回。</p>
</li>
</ol>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="请求分段中的硬件支持"><a href="#请求分段中的硬件支持" class="headerlink" title="请求分段中的硬件支持"></a>请求分段中的硬件支持</h3><ol>
<li><p>段表机制</p>
<p>段名，段长，段基址，存取方式，访问位A，修改位M，存在位P，增补位，外存始址</p>
<p>增补位：是否做过动态增长</p>
</li>
<li><p>缺段中断机构</p>
<p>没有足够长的连续空闲区，但空闲容量足够，需要空区拼接，否则再淘汰其他段</p>
</li>
<li><p>地址变换机构</p>
</li>
</ol>
<h3 id="分段的共享和保护"><a href="#分段的共享和保护" class="headerlink" title="分段的共享和保护"></a>分段的共享和保护</h3><ol>
<li><p>共享段表</p>
<p>增加一张共享段表，相比段表中增加若干项，共享进程计数，对于每个共享该段的进程的记录，包括：状态，进程名，进程号，段号，存取控制</p>
</li>
<li><p>共享段的分配和回收</p>
<ol>
<li>分配，对于第一次调用count置于1，否则count:=count+1，增加共享段表中新进程相关信息</li>
<li>回收，count:=count-1，撤销共享段表中进程相关信息，若count为0收回该共享段的物理内存，取消共享段表中的该段对应表项。</li>
</ol>
</li>
<li><p>分段保护</p>
<ol>
<li><p>越界检查</p>
</li>
<li><p>存取控制检查</p>
</li>
<li><p>环保护检查</p>
<p>低标号的环优先级高</p>
<p>一个程序可以访问驻留在相同环或较低特权环中的数据</p>
<p>一个程序可以调用驻留在相同环或较高特权环中的服务</p>
</li>
</ol>
</li>
</ol>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><p>处理IO请求，提高IO速率，改善IO设备利用率</p>
<h2 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><ol>
<li>I/O设备的类型<ol>
<li>按设备的使用特性分类，存储设备，输入输出设备</li>
<li>按传输速率分类，低俗设备（键鼠），中速设备（打印机），高速设备（磁盘）</li>
<li>按信息交换的单位分类，块设备（可寻址，DMA），字符设备（不可寻址，中断驱动）</li>
<li>按设备的共享属性分类，独占设备，虚拟设备，共享设备</li>
</ol>
</li>
<li>设备与控制器之间的接口<ol>
<li>数据信号线，传输数据，有缓冲区</li>
<li>控制信号线，控制信号</li>
<li>状态信号线，当前状态的信号，正在读写或已完成读写</li>
</ol>
</li>
</ol>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。可编制用于控制不同的设备。可分为字符设备的控制器，与块设备的控制器</p>
<ol>
<li>设备控制器的基本功能<ol>
<li>接受和识别命令</li>
<li>数据交换，CPU与控制器之间，控制器和设备之间的数据交换，前者依赖数据总线</li>
<li>标识和报告设备的状态</li>
<li>地址标识，识别和控制每个设备的地址 </li>
<li>数据缓冲，I/O设备低速而CPU和内存高速，故而需要设置缓冲区</li>
<li>差错检测，采用重传的策略</li>
</ol>
</li>
<li>设备控制器的组成<ol>
<li>设备控制器与处理机的接口，数据线，地址线，控制线，数据寄存器，控制/状态寄存器</li>
<li>设备控制器与设备的接口，一个接口连接一台设备，每个接口存在数据、控制和状态三种类型的信号</li>
<li>I/O逻辑，对收到的命令译码</li>
</ol>
</li>
</ol>
<h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h3><ol>
<li><p>I/O通道设备的引入</p>
<p>为了减轻CPU负担而引入，通道是一种特殊的处理机，具有执行I/O指令的能力，与CPU共享内存</p>
</li>
<li><p>通道类型</p>
<ol>
<li>字节多路通道，时间片轮转，每个设备传输一个字节，低速设备</li>
<li>数组选择通道，一段时间内一个设备独占，高速设备，低利用率</li>
<li>数组多路通道，各设备分时并行传输，高速设备，高利用率</li>
</ol>
</li>
<li><p>瓶颈问题</p>
<p>若设备到存储器间只有一条通路，那假如通道或控制器任一被占用则不可正常传输</p>
<p>解决方法，一个设备连接到多个控制器上，一个控制器连到多个通道上</p>
</li>
</ol>
<h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><ol>
<li>ISA和EISA总线<ol>
<li>ISA总线，带宽八位</li>
<li>EISA总线，带宽32位</li>
</ol>
</li>
<li>局部总线，需求更高的传输速率，将设备通过局部总线控制器直接接到CPU总线上<ol>
<li>VESA总线</li>
<li>PCI总线</li>
</ol>
</li>
</ol>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序I-O方式"><a href="#程序I-O方式" class="headerlink" title="程序I/O方式"></a>程序I/O方式</h3><p>未就绪就原地等待</p>
<h3 id="中断驱动I-O控制方式"><a href="#中断驱动I-O控制方式" class="headerlink" title="中断驱动I/O控制方式"></a>中断驱动I/O控制方式</h3><p>I/O就绪后对CPU发中断信号，数据以字节为单位，每完成一个单位中断一次</p>
<h3 id="直接存储器访问-DMA-I-O控制方式"><a href="#直接存储器访问-DMA-I-O控制方式" class="headerlink" title="直接存储器访问(DMA)I/O控制方式"></a>直接存储器访问(DMA)I/O控制方式</h3><ol>
<li><p>DMA控制方式的引入</p>
<p>数据以数据块为单位，数据直接送往内存，仅在数据传输的开始与结束时需要CPU干预</p>
</li>
<li><p>DMA控制器的组成</p>
<p>主机-DMA控制器接口，DMA控制器与块设备的接口，I/O控制逻辑</p>
<p>主机-DMA控制器接口中的四类寄存器：</p>
<ol>
<li>命令/状态寄存器(CR)，接受I/O命令，控制信息，设备状态</li>
<li>内存地址寄存器(MAR)，输入时，送入内存的地址；输出时，内存到设备的源地址</li>
<li>数据寄存器(DR)，暂存数据</li>
<li>数据计数器(DC)。存放本次CPU要读写的字(节)数</li>
</ol>
</li>
<li><p>DMA工作过程</p>
<p>设置MAR与DC初值-启动DMA传送命令-传送数据字-存储器地址增1，DC减1-传送数据直到DC=0</p>
</li>
</ol>
<h3 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h3><ol>
<li><p>I/O通道控制方式的引入</p>
<p>为了实现离散的数据块的一次性读入，即对一组数据块的读(或写)及有关的控制和管理为单位的干预。具体的实现方法是将多条读写指令封装为一个通道程序，通道程序结束后再中断CPU</p>
</li>
<li><p>通道程序</p>
<p>通道程序中含若干条指令，其中每条指令都包括：</p>
<ol>
<li>操作码，规定所做的操作</li>
<li>内存地址，内存首址</li>
<li>计数，字节数</li>
<li>通道程序结束位P，表明通道程序是否结束，该条指令是不是通道程序的最后一个指令</li>
<li>记录结束标志R，本条指令与下一条指令是否同属于一个记录</li>
</ol>
</li>
</ol>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><h3 id="缓冲的引入"><a href="#缓冲的引入" class="headerlink" title="缓冲的引入"></a>缓冲的引入</h3><ol>
<li>缓和CPU和I/O设备间的速度不匹配</li>
<li>减少对CPU的中断频率</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ol>
<h3 id="单缓冲和双缓冲"><a href="#单缓冲和双缓冲" class="headerlink" title="单缓冲和双缓冲"></a>单缓冲和双缓冲</h3><ol>
<li><p>单缓冲</p>
<p>设置一个缓冲区，读写不可并行。</p>
</li>
<li><p>双缓冲</p>
<p>设置两个缓冲区，当一个缓冲区装满后，I/O设备转去另一缓冲区，同时CPU取走第一缓冲区。</p>
</li>
</ol>
<p>两台机器通信时如果仅为他们配置单缓冲，那么任一时刻都只能单向传输。为了实现双向数据传输，必须在两台机器都配置两个缓冲区，一个用作发送缓冲区，一个用作接收缓冲区。</p>
<h3 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h3><p>为了速度相差过大的情况，设置多个缓冲区</p>
<ol>
<li><p>循环缓冲的组成</p>
<ol>
<li>多个缓冲区：空缓冲区R，满缓冲区G以及正在使用的工作缓冲区C</li>
<li>多个指针：指示下一个满缓冲区，指示下一个空缓冲区，指示正在使用的缓冲区</li>
</ol>
</li>
<li><p>循环缓冲区的使用</p>
<ol>
<li><p>Getbuf</p>
<p>计算进程调用该过程使用Nextg所指示的缓冲区，将其变为Current指向的缓冲区，将NextG指向下一个G缓冲区。输入进程用Getbuf获取下一个R缓冲区</p>
</li>
<li><p>Releasebuf过程</p>
<p>计算进程将数据提取完后调用该过程将其变为R缓冲区，输入进程装满缓冲区后调用该进程将其变为G缓冲区</p>
</li>
</ol>
</li>
<li><p>进程同步</p>
<ol>
<li>Nexti追上Nextg:输入速度大于计算速度，阻塞输入进程，直至有空缓冲区</li>
<li>Nextg追上Nexti:计算速度大于输入速度，阻塞计算进程，直至有满缓冲区</li>
</ol>
</li>
</ol>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲区为进程专属，利用率不高，故而公用缓冲池更为流行</p>
<ol>
<li><p>缓冲池的组成</p>
<p>空缓冲区，装满输出数据的缓冲区，装满输入数据的缓冲区</p>
<p>空缓冲队列emq，输入队列inq，输出队列outq</p>
<p>用于收容输入数据的工作缓冲区</p>
<p>用于提取输入数据的工作缓冲区</p>
<p>用于收容输出数据的工作缓冲区</p>
<p>用于提取输出数据的工作缓冲区</p>
</li>
<li><p>Getbuf过程Putbuf过程</p>
<p>缓冲池中的队列本身是临界资源，多个进程在访问一个队列时，即应互斥， 又须同步</p>
<p>为了互斥，应该每个队列设置一个互斥信号量MS(type)</p>
<p>为了同步，应该每个队列设置一个资源信号量RS(type)</p>
<p>对于getbuf，既要互斥地访问临界区，也要等待资源，需要wait(RS(type))</p>
<p>对于putbuf，既要互斥地访问临界区，在放回资源后，需要signal(RS(type))。</p>
</li>
<li><p>缓冲区的工作方式</p>
<p>收容输入，提取输入，收容输出提取输出共四种工作方式</p>
<ol>
<li>收容输入，输入进程取空缓冲队列的缓冲区，装满后放回输入队列</li>
<li>提取输入，计算进程取输入队列的缓冲区，用完后放回空缓冲队列</li>
<li>收容输出，收容输入同理</li>
</ol>
</li>
</ol>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>设备的独立性，应用程序独立于具体使用的物理设备，为了实现设备独立性引入了逻辑设备和物理设备两个概念。用设备独立性软件实现</p>
<p>设备分配必须由系统完成</p>
<h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><ol>
<li><p>设备控制表DCT</p>
<p>为每个设备都配置一张设备控制表，用于记录本设备的情况</p>
<ol>
<li>设备类型，设备标识符</li>
<li>设备队列队首指针，PCB按一定的策略</li>
<li>设备状态，设备，控制器和通道是否忙</li>
<li>与设备连接的控制器表指针，指向该设备所连接的控制器的控制表，如果连接多个控制器，应设置多个控制器表指针</li>
<li>重复执行次数，如果传送失败，则需要重传，重传次数过多达到规定值则认为传送失败</li>
</ol>
</li>
<li><p>控制器控制表。通道控制表和系统设备表</p>
<ol>
<li>控制器控制表COCT，控制器标识符，控制器状态，域控制器链接的通道表指针，控制器队列的队首指针，控制器队列的队尾指针</li>
<li>通道控制表CHCT，通道标识符，通道状态，与通道连接的控制器表的首址，通道队列的队首指针，通道队列的队尾指针</li>
<li>系统设备表，系统范围内的，记录了系统中全部设备的情况。每个设备占一个表目。表项有设备类型，设备标识符，设备控制表及设备驱动程序的入口</li>
</ol>
</li>
</ol>
<h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><ol>
<li><p>设备的固有属性</p>
<ol>
<li>独占设备，被系统分配后被独占，等进程释放设备后系统再分配。缺点在于设备得不到充分利用，而且还可能引起死锁</li>
<li>共享设备，可同时分配给多个进程使用，需注意对访问的先后次序进行合理的调度</li>
<li>可虚拟设备，使用虚拟技术将设备虚拟成多个设备，因而，可虚拟设备是可共享的设备。</li>
</ol>
</li>
<li><p>设备分配算法</p>
<p>先来先服务，优先级高者优先</p>
</li>
<li><p>设备分配中的安全性</p>
<ol>
<li><p>安全分配模式</p>
<p>进程发出I/O请求后阻塞进程，直至I/O操作完成后才被唤醒，摒弃了“请求和保持”的条件，缺点是进程进展缓慢，CPU和I/O设备串行工作</p>
</li>
<li><p>不安全分配方式</p>
<p>进程发出I/O请求后继续运行，需要时发出多个I/O请求。仅当进程所请求的设备已被另一进程占用时，请求进程才进入阻塞状态。优点，进程推进快，缺点可能造成死锁，需要进行对设备分配进行安全性计算</p>
</li>
</ol>
</li>
</ol>
<h3 id="独占设备的分配程序"><a href="#独占设备的分配程序" class="headerlink" title="独占设备的分配程序"></a>独占设备的分配程序</h3><ol>
<li><p>基本的设备分配程序</p>
</li>
<li><p>分配设备（需要计算设备分配安全性）-分配控制器-分配通道</p>
</li>
<li><p>设备分配程序的改进</p>
<p>增加设备的独立性，进程应使用逻辑设备名请求I/O，即进程申请的是某类设备而非某台指定的设备。</p>
<p>考虑多通路情况，为了防止出现“瓶颈”，设备可以连接多个控制器，按顺序查询是否有空闲，若无再将设备挂在控制器的等待队列</p>
</li>
</ol>
<h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><ol>
<li><p>什么是SPOOLing</p>
<p>因为多道程序技术带来的并发性，可以利用一个进程让<strong>CPU模拟外围控制器</strong>，将低速I/O设备的数据传送到磁盘上。</p>
</li>
<li><p>SPOOLing系统的组成</p>
<ol>
<li>输入井和输出井。磁盘上开辟的两个大存储空间，分别用于暂存I/O设备输入的数据和用于暂存用户程序的输出数据</li>
<li>输入缓冲区和输出缓冲区，用于缓和CPU和磁盘之间的速度不匹配的矛盾，在内存中开辟的两个缓冲区。分别用于暂存输入设备送来的数据，以后再送给输入井和暂存从输出井送来的数据以后在传送给输出设备</li>
<li>输入进程SPi和输出进程SP0，用两个进程模拟脱机I/O时的外围控制机。</li>
</ol>
<p>数据的流动在 设备-缓冲区(内存)-井(磁盘) 内进行整个过程由CPU(进程)调度</p>
</li>
<li><p>共享打印机</p>
<p>利用SPOOLing技术可将独占的打印机改造成共享设备。提高设备利用率，降低用户使用难度</p>
<p>当用户请求打印时</p>
<ol>
<li>输出进程在输出井中为之申请一个空闲磁盘块</li>
<li>输出进程再为用户进程申请一张空白的用户请求答应表，用户填写要求后，将其挂入请求打印队列</li>
</ol>
<p>输出进程对打印机的操作</p>
<ol>
<li>若打印机空闲，则从请求打印队列取出一张请求答应表</li>
<li>将数据传送到内存缓冲区</li>
<li>打印机打印</li>
</ol>
</li>
<li><p>SPOOLing系统的特点</p>
<ol>
<li>提高了I/O速度</li>
<li>将独占设备改造为共享速度</li>
<li>实现了虚拟设备功能</li>
</ol>
</li>
</ol>
<h2 id="磁盘存储器的管理"><a href="#磁盘存储器的管理" class="headerlink" title="磁盘存储器的管理"></a>磁盘存储器的管理</h2><p>磁盘管理器的优点：容量大，存取速度快，可以实现随机存储</p>
<h3 id="磁盘性能简述"><a href="#磁盘性能简述" class="headerlink" title="磁盘性能简述"></a>磁盘性能简述</h3><ol>
<li><p>数据的组织和格式</p>
<p>每个磁盘面有一个或两个<strong>磁盘面</strong>（磁盘面的上下平面），每个磁盘面分为若干个同心环，这种换称作<strong>磁道</strong>，磁道间需要有间隔，每条磁道上存储相同数目的二进制位，每条磁道逻辑上又被划分为若干个<strong>扇区</strong></p>
<p>为了提高存储能力，现代磁盘不再让每个磁道拥有同样的扇区数，而是将磁道划分出若干个环带，同环带的磁道拥有相同的扇区数。</p>
<p>磁盘低级格式化为控制信息区和数据区，每个扇区都包含两个字段：标识符字段，数据字段</p>
<p>格式化完成后一般要对磁盘分区，在逻辑上每个分区就是一个独立的逻辑磁盘，每个分区的起始扇区和大小都记录在磁盘0扇区的主引导记录分区表所包含的分区表中</p>
<p>高级格式化，设置一个引导块、空闲存储管理、根目录和一个空文件系统，同时在分区表中标识该分区所使用的文件系统</p>
</li>
<li><p>磁盘的类型</p>
<ol>
<li>固定头磁盘，每条磁道上都有读写磁头</li>
<li>移动头磁盘，每一个盘面一个磁头，移动寻道</li>
</ol>
</li>
<li><p>磁盘访问时间</p>
<ol>
<li>寻道时间$T_s$，移动磁头到指定磁道的时间</li>
<li>旋转延迟时间$T_r$，等待指定扇区移动到磁头下的时间，一般用转速倒数的二分之一作为平均值</li>
<li>传输时间$T_t$，等待磁头扫描完所需要读的数据在物理上的长度</li>
</ol>
<p>合计$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$，主要时间来自于寻道时间，应该逻辑上连续的数据放在物理上连续的位置</p>
</li>
</ol>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ol>
<li><p>先来先服务</p>
</li>
<li><p>最短寻道时间优先</p>
<p>优先将磁头移动到离当前磁道最近的磁道上，可能导致饥饿</p>
</li>
<li><p>SCAN算法</p>
<ol>
<li>SCAN算法，将磁头移动到当前磁头移动方向上最近的磁道，没有则转向</li>
<li>循环扫描(CSCAN)算法，为了避免在磁头刚移动的位置出现访问，导致等待时间过长，规定磁头单向移动，进行循环扫描，每次到达终点后回到起点再开始扫描</li>
</ol>
</li>
<li><p>NstepSCAN和FSCAN算法</p>
<ol>
<li><p>NStepSCAN算法</p>
<p>若某磁道上一直存在访问请求，可能导致磁头被该磁道垄断，为了避免，将磁盘请求队列粉煤若干个长度为N的队列，队列间采取先来先服务，队列内按SCAN算法</p>
</li>
<li><p>FSCAN算法</p>
<p>分为两个队列，每次调度过程中新到的请求都放置于另一个队列中，所有新请求都推迟到下一次扫描</p>
</li>
</ol>
</li>
</ol>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h2><h3 id="文件、记录和数据项"><a href="#文件、记录和数据项" class="headerlink" title="文件、记录和数据项"></a>文件、记录和数据项</h3><ol>
<li><p>数据项</p>
<ol>
<li>基本数据项，原子数据，描述某种属性的字符集，应该有数据类型</li>
<li>组合数据项，若干个基本数据项组成的</li>
</ol>
</li>
<li><p>记录</p>
<p>记录是一组相关<strong>数据项的集合</strong>，用于描述<strong>一个对象</strong>在某方面的属性。为了唯一标识一个记录，需要有不重复的关键字</p>
</li>
<li><p>文件</p>
<p>有结构文件中，文件由<strong>若干个相关记录组成</strong></p>
<p>无结构文件则被视作一个字符流</p>
<p>文件在文件系统中是一个最大的数据单位，描述了一个对象集。一个文件必须要有一个文件名，用以用户访问。</p>
<p>文件属性：</p>
<ol>
<li>文件类型</li>
<li>文件长度</li>
<li>文件的物理位置</li>
<li>文件的建立时间</li>
</ol>
</li>
</ol>
<h3 id="文件类型和文件系统模型"><a href="#文件类型和文件系统模型" class="headerlink" title="文件类型和文件系统模型"></a>文件类型和文件系统模型</h3><ol>
<li><p>文件类型</p>
<ol>
<li>用途分类：系统文件(x)、用户文件(rwx)和库文件(x)</li>
<li>文件中的数据的形式分类：源文件、目标文件和可执行文件</li>
<li>按存取控制分类：只执行文件，只读文件和读写文件</li>
<li>按组织形式和处理方式分类：普通文件、目录文件和特殊文件（各类I/O设备）</li>
</ol>
</li>
<li><p>文件系统模型</p>
<p>用户-文件系统接口-对对象操纵和管理的软件集合-对象及其属性</p>
<ol>
<li>对象及其属性：文件、目录（文件名及其指针）和磁盘存储空间</li>
<li>对对象操纵和管理的软件集合：<strong>文件管理系统核心</strong>，包括对对象存储空间的管理、对文件目录的管理、将文件的逻辑地址转换为物理地址的机制、对文件读写的管理、对文件的共享与保护等</li>
<li>文件系统的接口：命令接口和程序接口（系统调用）</li>
</ol>
</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol>
<li><p>最基本文件操作</p>
<ol>
<li>创建文件：分配外存空间、目录中为其建立目录项。</li>
<li>删除文件：删除目录中的目录项，回收存储空间</li>
<li>读文件：给系统调用提供文件名和应读入的内存目标地址。系统去查找目录，找到指定目录项，找到外存中的位置，还需要一个控制读写</li>
<li>写文件：同上</li>
<li>截断文件：将文件的长度设置为零，放弃文件的原有内容</li>
<li>设置文件的读写位置，实现随机存取</li>
</ol>
</li>
<li><p>文件的打开和关闭操作</p>
<p>打开：从外存拷贝到内存打开文件表的一个表目中，并返回表目的索引。</p>
<p>关闭：从打开文件表中删除对应表目</p>
</li>
<li><p>其他文件操作</p>
<p>对文件属性的操作</p>
<p>目录的操作</p>
</li>
</ol>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><ol>
<li>文件的逻辑结构，用户观点出发观察到的文件组织形式。</li>
<li>文件的物理结构，文件在外存上的存储组织形式</li>
</ol>
<h3 id="文件逻辑结构的类型"><a href="#文件逻辑结构的类型" class="headerlink" title="文件逻辑结构的类型"></a>文件逻辑结构的类型</h3><ol>
<li><p>有结构文件</p>
<p>记录式文件：</p>
<ol>
<li>定长记录，每个记录的长度都是固定相同的</li>
<li>各记录的长度不相同</li>
</ol>
<p>记录组织方式：</p>
<ol>
<li>顺序文件，按某种顺序形成。通常是定长记录</li>
<li>索引文件，利用建立记录的索引表以加速检索速度</li>
<li>索引顺序表</li>
</ol>
</li>
<li><p>无结构文件</p>
<p>即流式文件。采用读写指针指出下一个要访问的字符</p>
</li>
</ol>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><ol>
<li><p>逻辑记录的排序</p>
<p>串结构，顺序与关键字无关，通常按存入时间来决定先后排序</p>
<p>顺序结构，按关键字排序，更快的检索速度</p>
</li>
<li><p>对顺序文件的读写操作</p>
<p>即记录地址的差是记录的长度</p>
</li>
<li><p>顺序文件的优缺点</p>
<p>批量读写快，查找修改单个记录慢</p>
</li>
</ol>
<h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>建立索引表，用空间换取时间</p>
<h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>为顺序文件建立索引表，克服了变长记录文件不便于直接存取的缺点，并可以通过索引表实现折半检索</p>
<h3 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h3><ol>
<li><p>直接文件</p>
<p>记录键值本身就决定了记录的物理地址，组织直接文件的关键在于用什么方式进行从记录值到物理地址的转换。</p>
</li>
<li><p>哈希文件</p>
<p>目前应用最为广泛的一种直接文件，利用哈希函数将记录键值转换为相应记录的地址</p>
</li>
</ol>
<h2 id="外存分配方式"><a href="#外存分配方式" class="headerlink" title="外存分配方式"></a>外存分配方式</h2><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><ol>
<li>连续分配的方式，为每一个文件分配一组相邻接的盘块，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中。和内存动态分区一样可以用紧凑完成碎片的消除</li>
<li>顺序分配的主要优缺点<ol>
<li>顺序访问容易</li>
<li>顺序访问速度快</li>
<li>要求有连续的存储空间</li>
<li>需要事先知道文件的长度</li>
</ol>
</li>
</ol>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>通过在每个盘块上的链接指针将同属于一个文件的多个离散的盘块链接成一个链表</p>
<ol>
<li><p>隐式链接，目录中只存储开始盘块号和结束盘块号，下一个盘块指针存储在盘块中（等同于链表）。可靠性差，要求每个指针都不出错。</p>
</li>
<li><p>显式链接</p>
<p>各物理块的指针显示地存放在内存的一张链接表中，该表在整个磁盘仅设置一张。该表称作文件分配表FAT</p>
</li>
</ol>
<h3 id="FAT和NTFS技术"><a href="#FAT和NTFS技术" class="headerlink" title="FAT和NTFS技术"></a>FAT和NTFS技术</h3><ol>
<li><p>FAT12，每个FAT表目长度为12($2^{12}$个表项)位，每个表目对应的外存存储空间即一簇可以为一个扇区（512B）、两个扇区、四个扇区、八个扇区等。增大簇的大小的同时，可能会造成更大的簇内零头。可将物理磁盘分为若干个逻辑磁盘，也称为卷</p>
</li>
<li><p>FAT16，每个FAT表母长度位16位，改善了FAT12，但改善得有限。每个簇的大小可以为128KB</p>
</li>
<li><p>FAT32，每个簇固定为4KB，最大存储空间为2TB，不再向下兼容</p>
</li>
<li><p>NTFS</p>
<ol>
<li><p>NTFS新特性：使用了64位的磁盘地址，更长的文件名与全路径名，系统容错，数据一致性。文件加密与压缩</p>
</li>
<li><p>磁盘组织</p>
<p>以簇为磁盘空间分配和回收的基本单位。可以不需要知道盘块的大小。大多数情况下簇的大小为4KB</p>
<p>逻辑簇号，以卷为单位，将整个卷中所有的簇按顺序进行简单的编号</p>
<p>虚拟簇号，将属于某个文件的簇按顺序进行编号</p>
</li>
<li><p>文件的组织，不知道考不考，暂略</p>
</li>
</ol>
<p>不向下兼容</p>
</li>
</ol>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><ol>
<li><p>单级索引分配</p>
<p>缺点：</p>
<ol>
<li>不能支持高校的直接存取</li>
<li>FAT占用较大的内存空间</li>
</ol>
<p>为每个文件分配一个索引块，再将把分配给该文件的所有盘块号都记录在该索引块上。目录上存在对应索引块的指针</p>
</li>
<li><p>多级索引分配</p>
<p>如果分配的盘块号已经装满了一个索引块，分配另一个索引块将以后分配的盘块号记录在其中，再通过建立索引的索引，将多个索引块组织起来</p>
</li>
<li><p>混合索引分配方式</p>
<p>将多种索引分配方式相结合。再UNIX中使用。</p>
<ol>
<li>直接地址，iaddr(0)~iaddr(9)存放直接地址，用于小文件存储</li>
<li>一次间接地址，iaddr(10)，即单级索引</li>
<li>多次间接地址</li>
</ol>
</li>
</ol>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><ol>
<li>实现“按名存取”</li>
<li>提高对目录的检索速度</li>
<li>文件共享</li>
<li>允许文件重名</li>
</ol>
<h3 id="文件控制块与索引结点"><a href="#文件控制块与索引结点" class="headerlink" title="文件控制块与索引结点"></a>文件控制块与索引结点</h3><p>为文件设置用于描述和控制的数据结构称之为“文件控制块FCB”。而人们把文件控制块的有序集合称为文件目录。通常，一个文件目录也被看作是一个文件称为目录文件。</p>
<ol>
<li><p>文件控制块</p>
<ol>
<li>基本信息类：文件名，文件物理位置，文件逻辑结构与文件物理结构</li>
<li>存取控制信息类：文件的存取权限，核准用户的存取权限以及一般用户的存取权限</li>
<li>使用信息类：文件的建立时间，上次修改时间及当前使用信息</li>
</ol>
</li>
<li><p>索引结点</p>
<ol>
<li><p>索引结点的引入</p>
<p>检索目录文件的过程只用到了文件名，其余的描述信息均可在检索时忽略。故而可以对FCB做一个索引表，其中只有文件名和索引节点编号，从而减少检索过程中对磁盘的读取的次数。</p>
<p>注：文件名与文件信息分离，文件名存放于文件目录中，文件描述信息存放于索引节点中（例如unix的inode）。</p>
</li>
<li><p>磁盘索引结点</p>
<p>存放于磁盘上的索引结点。每个文件有唯一一个磁盘索引结点。</p>
<p>包括：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度，文件连接计数及文件存取时间。</p>
</li>
<li><p>内存索引节点</p>
<p>存放于内存上的索引结点。</p>
<p>包括：索引结点编号，状态（指示是否上锁或修改），访问计数（共享数），文件所属文件系统的逻辑设备号及链接指针</p>
</li>
</ol>
</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li><p>单级目录结构</p>
<p>整个文件系统之建立一个目录表。目录项中含的文件名，文件扩展名，文件长度，文件类型，文件物理地址及其他文件属性。此外为了标识目录项是否空闲，再增加一个状态位。</p>
<p>优点：简单</p>
<p>缺点：查找慢，不允许重名及不便于实现文件共享</p>
</li>
<li><p>两级目录</p>
<p>为每一个用户建立一个单独的用户文件目录，再在系统中建立一个主目录用户。主用户目录包括文件名和指向用户目录的指针。</p>
<p>优点：检索快，不同用户的文件可以重名及不同用户可用不同的文件名访问一个共享文件。</p>
</li>
<li><p>多级目录结构</p>
<ol>
<li><p>目录结构</p>
<p>采用树的结构。</p>
</li>
<li><p>路径名</p>
<p>根到叶子存在唯一的路径</p>
</li>
<li><p>当前目录</p>
<p>相对路径，绝对路径</p>
</li>
<li><p>增加删除目录</p>
<p>空目录直接删除，非空目录删除时目录内的文件均需删除</p>
</li>
</ol>
</li>
</ol>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><ol>
<li>线性检索法，简单顺序检索当前目录。</li>
<li>Hash方法</li>
</ol>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><h3 id="空闲表法和空闲链表法"><a href="#空闲表法和空闲链表法" class="headerlink" title="空闲表法和空闲链表法"></a>空闲表法和空闲链表法</h3><ol>
<li>空闲表<ol>
<li>空闲表，内存的动态分配方式雷同，包括第一空闲盘块号，空闲盘块数</li>
<li>存储空间的分配与回收，与内存的动态分配方式相似，但在外存管理中，常常用连续分配方式。</li>
</ol>
</li>
<li>空闲链表法<ol>
<li>空闲盘块链</li>
<li>空闲盘区链</li>
</ol>
</li>
</ol>
<h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><ol>
<li><p>位示图，为每一个盘块标识是否空闲。并将此用二维表格展示</p>
</li>
<li><p>盘块的分配</p>
<p>顺序扫描位示图找到空闲，将其二维坐标转换为一维地址，修改位示图</p>
</li>
<li><p>盘块的回收</p>
<p>将一维地址转换为位示图的二维坐标，修改位示图</p>
</li>
</ol>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>用一个盘块存储空闲盘块号，其中存储空闲盘块数，一个用于存储空闲盘块号的盘块的地址，剩余空间用于存储空闲盘块的盘块号。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于索引结点的共享方式"><a href="#基于索引结点的共享方式" class="headerlink" title="基于索引结点的共享方式"></a>基于索引结点的共享方式</h3><p>又称软连接，文件目录记录被共享文件的索引节点的物理地址，故该链接方式下的文件共享一个索引节点，也即共享一个引用计数值。删除文件需要修改索引节点，只有count=0时才真正删除。</p>
<h3 id="利用符号链实现文件共享"><a href="#利用符号链实现文件共享" class="headerlink" title="利用符号链实现文件共享"></a>利用符号链实现文件共享</h3><p>又称硬链接，创建一个新文件，文件内容为被共享文件的路径名，因为是创建了一个新文件，故而不共享一个索引节点，也即不共享一个引用计数值。可能造成多级的文件共享，A-&gt;B-&gt;C导致多次读盘，开销大。</p>
<p>这两种方法都会在遍历整个文件系统时多次读取到一个文件。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/考研笔记/" rel="tag"># 考研笔记</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2021/05/29/软件工程-笔记/" rel="next" title="软件工程-笔记">
                  <i class="fa fa-chevron-left"></i> 软件工程-笔记
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2021/09/14/数据结构-考研/" rel="prev" title="数据结构-考研">
                  数据结构-考研 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#考纲"><span class="nav-number">1.</span> <span class="nav-text">考纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统引论"><span class="nav-number">2.</span> <span class="nav-text">操作系统引论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的目标与作用"><span class="nav-number">2.1.</span> <span class="nav-text">操作系统的目标与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的目标"><span class="nav-number">2.1.1.</span> <span class="nav-text">操作系统的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">2.1.2.</span> <span class="nav-text">操作系统的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推动操作系统发展的主要动力"><span class="nav-number">2.1.3.</span> <span class="nav-text">推动操作系统发展的主要动力</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的发展过程"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统的发展过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无操作系统的计算机系统"><span class="nav-number">2.2.1.</span> <span class="nav-text">无操作系统的计算机系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单道批处理系统"><span class="nav-number">2.2.2.</span> <span class="nav-text">单道批处理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多道批处理系统"><span class="nav-number">2.2.3.</span> <span class="nav-text">多道批处理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分时系统"><span class="nav-number">2.2.4.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时系统"><span class="nav-number">2.2.5.</span> <span class="nav-text">实时系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微机操作系统的发展"><span class="nav-number">2.2.6.</span> <span class="nav-text">微机操作系统的发展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的基本特性"><span class="nav-number">2.3.</span> <span class="nav-text">操作系统的基本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发性"><span class="nav-number">2.3.1.</span> <span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享性"><span class="nav-number">2.3.2.</span> <span class="nav-text">共享性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟技术"><span class="nav-number">2.3.3.</span> <span class="nav-text">虚拟技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步性"><span class="nav-number">2.3.4.</span> <span class="nav-text">异步性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的主要功能"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统的主要功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器管理功能"><span class="nav-number">2.4.1.</span> <span class="nav-text">处理器管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器管理功能"><span class="nav-number">2.4.2.</span> <span class="nav-text">存储器管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备管理功能"><span class="nav-number">2.4.3.</span> <span class="nav-text">设备管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件管理功能"><span class="nav-number">2.4.4.</span> <span class="nav-text">文件管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统与用户之间的接口"><span class="nav-number">2.4.5.</span> <span class="nav-text">操作系统与用户之间的接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS结构设计"><span class="nav-number">2.5.</span> <span class="nav-text">OS结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统的操作系统结构"><span class="nav-number">2.5.1.</span> <span class="nav-text">传统的操作系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微内核OS结构"><span class="nav-number">2.5.2.</span> <span class="nav-text">微内核OS结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程管理"><span class="nav-number">3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">进程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的顺序执行及其特征"><span class="nav-number">3.1.1.</span> <span class="nav-text">程序的顺序执行及其特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前驱图-DAG"><span class="nav-number">3.1.2.</span> <span class="nav-text">前驱图 DAG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的并发执行及其他特征"><span class="nav-number">3.1.3.</span> <span class="nav-text">程序的并发执行及其他特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的特征与状态"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程的特征与状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB"><span class="nav-number">3.1.5.</span> <span class="nav-text">PCB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.2.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的创建"><span class="nav-number">3.2.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的中止"><span class="nav-number">3.2.2.</span> <span class="nav-text">进程的中止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的阻塞与唤醒"><span class="nav-number">3.2.3.</span> <span class="nav-text">进程的阻塞与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的挂起与激活"><span class="nav-number">3.2.4.</span> <span class="nav-text">进程的挂起与激活</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程同步"><span class="nav-number">3.3.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量机制"><span class="nav-number">3.3.2.</span> <span class="nav-text">信号量机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量的应用"><span class="nav-number">3.3.3.</span> <span class="nav-text">信号量的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程机制"><span class="nav-number">3.3.4.</span> <span class="nav-text">管程机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典进程同步问题"><span class="nav-number">3.4.</span> <span class="nav-text">经典进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者-消费者问题"><span class="nav-number">3.4.1.</span> <span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家用餐问题"><span class="nav-number">3.4.2.</span> <span class="nav-text">哲学家用餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">3.4.3.</span> <span class="nav-text">读者-写者问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥"><span class="nav-number">3.5.</span> <span class="nav-text">进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信的类型"><span class="nav-number">3.5.1.</span> <span class="nav-text">进程通信的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递通信的实现"><span class="nav-number">3.5.2.</span> <span class="nav-text">消息传递通信的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递系统实现的若干问题"><span class="nav-number">3.5.3.</span> <span class="nav-text">消息传递系统实现的若干问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息缓冲队列通信机制"><span class="nav-number">3.5.4.</span> <span class="nav-text">消息缓冲队列通信机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">3.6.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的基本概念"><span class="nav-number">3.6.1.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间的同步和通信"><span class="nav-number">3.6.2.</span> <span class="nav-text">线程间的同步和通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的实现方式"><span class="nav-number">3.6.3.</span> <span class="nav-text">线程的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的实现"><span class="nav-number">3.6.4.</span> <span class="nav-text">线程的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理机调度与死锁"><span class="nav-number">4.</span> <span class="nav-text">处理机调度与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理机调度的层次"><span class="nav-number">4.1.</span> <span class="nav-text">处理机调度的层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高级调度"><span class="nav-number">4.1.1.</span> <span class="nav-text">高级调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#低级调度"><span class="nav-number">4.1.2.</span> <span class="nav-text">低级调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中级调度"><span class="nav-number">4.1.3.</span> <span class="nav-text">中级调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度队列模型对调度准则"><span class="nav-number">4.2.</span> <span class="nav-text">调度队列模型对调度准则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度队列模型"><span class="nav-number">4.2.1.</span> <span class="nav-text">调度队列模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择调度方式和调度算法的若干准则"><span class="nav-number">4.2.2.</span> <span class="nav-text">选择调度方式和调度算法的若干准则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度算法"><span class="nav-number">4.3.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务和短作业优先调度算法"><span class="nav-number">4.3.1.</span> <span class="nav-text">先来先服务和短作业优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高优先权优先调度算法"><span class="nav-number">4.3.2.</span> <span class="nav-text">高优先权优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于时间片的轮转调度算法"><span class="nav-number">4.3.3.</span> <span class="nav-text">基于时间片的轮转调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实时调度"><span class="nav-number">4.4.</span> <span class="nav-text">实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现实时调度的基本条件"><span class="nav-number">4.4.1.</span> <span class="nav-text">实现实时调度的基本条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时调度算法的分类"><span class="nav-number">4.4.2.</span> <span class="nav-text">实时调度算法的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的几种实时调度算法"><span class="nav-number">4.4.3.</span> <span class="nav-text">常用的几种实时调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#产生死锁的原因与必要条件"><span class="nav-number">4.5.</span> <span class="nav-text">产生死锁的原因与必要条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#产生死锁的原因"><span class="nav-number">4.5.1.</span> <span class="nav-text">产生死锁的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生死锁的必要条件"><span class="nav-number">4.5.2.</span> <span class="nav-text">产生死锁的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理死锁的基本方法"><span class="nav-number">4.5.3.</span> <span class="nav-text">处理死锁的基本方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预防死锁"><span class="nav-number">4.5.4.</span> <span class="nav-text">预防死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统安全状态"><span class="nav-number">4.5.5.</span> <span class="nav-text">系统安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用银行家算法避免死锁"><span class="nav-number">4.5.6.</span> <span class="nav-text">利用银行家算法避免死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的检测与解除"><span class="nav-number">4.6.</span> <span class="nav-text">死锁的检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的检测"><span class="nav-number">4.6.1.</span> <span class="nav-text">死锁的检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的解除"><span class="nav-number">4.6.2.</span> <span class="nav-text">死锁的解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储器管理"><span class="nav-number">5.</span> <span class="nav-text">存储器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器的层次结构"><span class="nav-number">5.1.</span> <span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多级存储器结构"><span class="nav-number">5.1.1.</span> <span class="nav-text">多级存储器结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主存储器与寄存器"><span class="nav-number">5.1.2.</span> <span class="nav-text">主存储器与寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高速缓存与磁盘缓存"><span class="nav-number">5.1.3.</span> <span class="nav-text">高速缓存与磁盘缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序的装入和链接"><span class="nav-number">5.2.</span> <span class="nav-text">程序的装入和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的装入"><span class="nav-number">5.2.1.</span> <span class="nav-text">程序的装入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的链接"><span class="nav-number">5.2.2.</span> <span class="nav-text">程序的链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续分配方式"><span class="nav-number">5.3.</span> <span class="nav-text">连续分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一连续分配"><span class="nav-number">5.3.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区分配"><span class="nav-number">5.3.2.</span> <span class="nav-text">固定分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区分配"><span class="nav-number">5.3.3.</span> <span class="nav-text">动态分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伙伴系统"><span class="nav-number">5.3.4.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希算法"><span class="nav-number">5.3.5.</span> <span class="nav-text">哈希算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重定位分区分配"><span class="nav-number">5.3.6.</span> <span class="nav-text">可重定位分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对换"><span class="nav-number">5.3.7.</span> <span class="nav-text">对换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本分页存储管理方式"><span class="nav-number">5.4.</span> <span class="nav-text">基本分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页面与页表"><span class="nav-number">5.4.1.</span> <span class="nav-text">页面与页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址变换机构"><span class="nav-number">5.4.2.</span> <span class="nav-text">地址变换机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级和多级页表"><span class="nav-number">5.4.3.</span> <span class="nav-text">两级和多级页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本分段存储管理方式"><span class="nav-number">5.5.</span> <span class="nav-text">基本分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分段存储管理方式的引入"><span class="nav-number">5.5.1.</span> <span class="nav-text">分段存储管理方式的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段系统的基本原理"><span class="nav-number">5.5.2.</span> <span class="nav-text">分段系统的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息共享"><span class="nav-number">5.5.3.</span> <span class="nav-text">信息共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式存储管理方式"><span class="nav-number">5.5.4.</span> <span class="nav-text">段页式存储管理方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟存储器的基本概念"><span class="nav-number">5.6.</span> <span class="nav-text">虚拟存储器的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器的引入"><span class="nav-number">5.6.1.</span> <span class="nav-text">虚拟存储器的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器的实现方法"><span class="nav-number">5.6.2.</span> <span class="nav-text">虚拟存储器的实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器的特征"><span class="nav-number">5.6.3.</span> <span class="nav-text">虚拟存储器的特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分页存储管理方式"><span class="nav-number">5.7.</span> <span class="nav-text">请求分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求分页中的硬件支持"><span class="nav-number">5.7.1.</span> <span class="nav-text">请求分页中的硬件支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配策略和分配算法"><span class="nav-number">5.7.2.</span> <span class="nav-text">内存分配策略和分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调页策略"><span class="nav-number">5.7.3.</span> <span class="nav-text">调页策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面置换算法"><span class="nav-number">5.8.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最佳置换算法和先进先出置换算法"><span class="nav-number">5.8.1.</span> <span class="nav-text">最佳置换算法和先进先出置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近最久未使用-LRU-置换算法"><span class="nav-number">5.8.2.</span> <span class="nav-text">最近最久未使用(LRU)置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clock置换算法"><span class="nav-number">5.8.3.</span> <span class="nav-text">Clock置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他置换算法"><span class="nav-number">5.8.4.</span> <span class="nav-text">其他置换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分段存储管理方式"><span class="nav-number">5.9.</span> <span class="nav-text">请求分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求分段中的硬件支持"><span class="nav-number">5.9.1.</span> <span class="nav-text">请求分段中的硬件支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段的共享和保护"><span class="nav-number">5.9.2.</span> <span class="nav-text">分段的共享和保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设备管理"><span class="nav-number">6.</span> <span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O系统"><span class="nav-number">6.1.</span> <span class="nav-text">I/O系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O设备"><span class="nav-number">6.1.1.</span> <span class="nav-text">I/O设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备控制器"><span class="nav-number">6.1.2.</span> <span class="nav-text">设备控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O通道"><span class="nav-number">6.1.3.</span> <span class="nav-text">I/O通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总线系统"><span class="nav-number">6.1.4.</span> <span class="nav-text">总线系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O控制方式"><span class="nav-number">6.2.</span> <span class="nav-text">I/O控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序I-O方式"><span class="nav-number">6.2.1.</span> <span class="nav-text">程序I/O方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断驱动I-O控制方式"><span class="nav-number">6.2.2.</span> <span class="nav-text">中断驱动I/O控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接存储器访问-DMA-I-O控制方式"><span class="nav-number">6.2.3.</span> <span class="nav-text">直接存储器访问(DMA)I/O控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O通道控制方式"><span class="nav-number">6.2.4.</span> <span class="nav-text">I/O通道控制方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲管理"><span class="nav-number">6.3.</span> <span class="nav-text">缓冲管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲的引入"><span class="nav-number">6.3.1.</span> <span class="nav-text">缓冲的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单缓冲和双缓冲"><span class="nav-number">6.3.2.</span> <span class="nav-text">单缓冲和双缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环缓冲"><span class="nav-number">6.3.3.</span> <span class="nav-text">循环缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲池"><span class="nav-number">6.3.4.</span> <span class="nav-text">缓冲池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备分配"><span class="nav-number">6.4.</span> <span class="nav-text">设备分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设备分配中的数据结构"><span class="nav-number">6.4.1.</span> <span class="nav-text">设备分配中的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备分配时应考虑的因素"><span class="nav-number">6.4.2.</span> <span class="nav-text">设备分配时应考虑的因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占设备的分配程序"><span class="nav-number">6.4.3.</span> <span class="nav-text">独占设备的分配程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPOOLing技术"><span class="nav-number">6.4.4.</span> <span class="nav-text">SPOOLing技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘存储器的管理"><span class="nav-number">6.5.</span> <span class="nav-text">磁盘存储器的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘性能简述"><span class="nav-number">6.5.1.</span> <span class="nav-text">磁盘性能简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘调度"><span class="nav-number">6.5.2.</span> <span class="nav-text">磁盘调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件管理"><span class="nav-number">7.</span> <span class="nav-text">文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件和文件系统"><span class="nav-number">7.1.</span> <span class="nav-text">文件和文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件、记录和数据项"><span class="nav-number">7.1.1.</span> <span class="nav-text">文件、记录和数据项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件类型和文件系统模型"><span class="nav-number">7.1.2.</span> <span class="nav-text">文件类型和文件系统模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件操作"><span class="nav-number">7.1.3.</span> <span class="nav-text">文件操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的逻辑结构"><span class="nav-number">7.2.</span> <span class="nav-text">文件的逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件逻辑结构的类型"><span class="nav-number">7.2.1.</span> <span class="nav-text">文件逻辑结构的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序文件"><span class="nav-number">7.2.2.</span> <span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引文件"><span class="nav-number">7.2.3.</span> <span class="nav-text">索引文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引顺序文件"><span class="nav-number">7.2.4.</span> <span class="nav-text">索引顺序文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接文件和哈希文件"><span class="nav-number">7.2.5.</span> <span class="nav-text">直接文件和哈希文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外存分配方式"><span class="nav-number">7.3.</span> <span class="nav-text">外存分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连续分配"><span class="nav-number">7.3.1.</span> <span class="nav-text">连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接分配"><span class="nav-number">7.3.2.</span> <span class="nav-text">链接分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT和NTFS技术"><span class="nav-number">7.3.3.</span> <span class="nav-text">FAT和NTFS技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引分配"><span class="nav-number">7.3.4.</span> <span class="nav-text">索引分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录管理"><span class="nav-number">7.4.</span> <span class="nav-text">目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件控制块与索引结点"><span class="nav-number">7.4.1.</span> <span class="nav-text">文件控制块与索引结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录结构"><span class="nav-number">7.4.2.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录查询技术"><span class="nav-number">7.4.3.</span> <span class="nav-text">目录查询技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件存储空间的管理"><span class="nav-number">7.5.</span> <span class="nav-text">文件存储空间的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲表法和空闲链表法"><span class="nav-number">7.5.1.</span> <span class="nav-text">空闲表法和空闲链表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位示图法"><span class="nav-number">7.5.2.</span> <span class="nav-text">位示图法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成组链接法"><span class="nav-number">7.5.3.</span> <span class="nav-text">成组链接法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件共享"><span class="nav-number">7.6.</span> <span class="nav-text">文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于索引结点的共享方式"><span class="nav-number">7.6.1.</span> <span class="nav-text">基于索引结点的共享方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用符号链实现文件共享"><span class="nav-number">7.6.2.</span> <span class="nav-text">利用符号链实现文件共享</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/1564282856-carbon.png"
      alt="Paof Yueng">
  <p class="site-author-name" itemprop="name">Paof Yueng</p>
  <div class="site-description" itemprop="description">PAOFBLOG</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/PaofYueng" title="GitHub &rarr; https://github.com/PaofYueng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PaofYueng</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

</body>
</html>
